<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ShanYJ</title>
    <description>╭(╯^╰)╮吉吉的博客</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 15 Dec 2015 13:32:22 +0800</pubDate>
    <lastBuildDate>Tue, 15 Dec 2015 13:32:22 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Python APScheduler定时任务框架</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;组件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;原则&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;常用方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;三种调度&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;时间格式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;案例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;之前的Django文档管理系统项目中，有文件设置过期时间的功能，其中删除是通过celery定时任务每日凌晨来实现的，今天回过头又找了找定时任务，发现了一个及其简便的定时任务框架：APScheduler。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;安装&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;pip install apscheduler&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;组件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;触发器(trigger)&lt;/strong&gt;:包含调度逻辑，每一个作业有它自己的触发器，用于决定接下来哪一个作业会运行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作业存储(job store)&lt;/strong&gt;:存储被调度的作业，默认的作业存储是简单地把作业保存在内存中，其他的作业存储是将作业保存在数据库中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;执行器(executor)&lt;/strong&gt;:处理作业的运行，他们通常通过在作业中提交制定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;调度器(scheduler)&lt;/strong&gt;:是其他的组成部分。你通常在应用只有一个调度器，应用的开发者通常不会直接处理作业存储、调度器和触发器，相反，调度器提供了处理这些的合适的接口。配置作业存储和执行器可以在调度器中完成，例如添加、修改和移除作业。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;调度器选择&lt;/strong&gt;:这取决于你的应用环境和你使用APScheduler的目的。通常最常用的两个：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;–BlockingScheduler: 当调度器是你应用中唯一要运行的东西时使用。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;–BackgroundScheduler: 当你不运行任何其他框架时使用，并希望调度器在你应用的后台执行。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作业存储选择&lt;/strong&gt;:你需要决定是否需要作业持久化。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;如果你总是在应用开始时重建job，你可以直接使用默认的作业存储（MemoryJobStore).&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果你需要将你的作业持久化，以避免应用崩溃和调度器重启时，你可以根据你的应用环境来选择具体的作业存储。例如：使用Mongo或者SQLAlchemyJobStore （用于支持大多数RDBMS）&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;执行器选择&lt;/strong&gt;:通常有两种:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;默认为ThreadPoolExecutor 通常用于大多数用途。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果你的工作负载中有较大的CPU密集型操作，你可以考虑用ProcessPoolExecutor来使用更多的CPU核。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;你也可以在同一时间使用两者，将进程池调度器作为第二执行器。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-4&quot;&gt;常用方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;添加作业&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;使用add_job():
scheduler.add_job(myfunc, ‘interval’, minutes=2)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用装饰器：@sched.scheduled_job(‘cron’, id=’my_job_id’, day=’last sun’)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;add_job的第二个参数是trigger，它管理着作业的调度方式。它可以为date, interval或者cron。对于不同的trigger，对应的参数也相同。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;移除作业&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;scheduler.remove_job(‘my_job_id’)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;暂停和继续作业&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;apscheduler.schedulers.base.BaseScheduler.pause_job()
apscheduler.schedulers.base.BaseScheduler.resume_job()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;获得job列表&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;scheduler.get_jobs()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;关闭调度器&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;scheduler.shutdown(wait=False)
默认情况下调度器会等待所有正在运行的作业完成后，关闭所有的调度器和作业存储。如果你不想等待，可以将wait选项设置为False。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-5&quot;&gt;三种调度&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;cron  定时调度&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;year: 4位数字&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;month: 月 (1-12)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;day: 天 (1-31)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;week: 标准周 (1-53)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;day_of_week: 周中某天 (0-6 or mon,tue,wed,thu,fri,sat,sun)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;hour: 小时 (0-23)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;minute:分钟 (0-59)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;second: 秒 (0-59)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;start_date: 最早执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;end_date: 最晚执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;timezone: 执行时间区间&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;interval  间隔调度&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;weeks: 每隔几周执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;days: 每隔几天执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;hours: 每隔几小时执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;minutes: 每隔几分执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;seconds: 每隔几秒执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;start_date: 最早执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;end_date: 最晚执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;timezone: 执行时间区间&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;date  定时调度&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;最基本的一种调度，作业只会执行一次。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;run_date: 在某天执行任务&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;timezone: 在某段时间执行任务&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-6&quot;&gt;时间格式&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Expression	Field	Description
*	         any	Fire on every value
*/a	         any	Fire everyavalues, starting from the minimum
a-b	         any	Fire on any value within thea-brange (a must be smaller than b)
a-b/c	     any	Fire everycvalues within thea-brange
xthy	     day	Fire on thex-th occurrence of weekdayywithin the month
lastx	     day	Fire on the last occurrence of weekdayxwithin the month
last	     day	Fire on the last day within the month
x,y,z	     any	Fire on any matching expression
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-7&quot;&gt;案例&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;可以先创建调度器，再配置和添加作业，这样你可以在不同的环境中得到更大的灵活性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面是一个简单使用BlockingScheduler，并使用默认内存存储和默认执行器。
(默认选项分别是MemoryJobStore和ThreadPoolExecutor，其中线程池的最大线程数为10)。配置完成后使用start()方法来启动。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
def my_job():
    print &#39;shanyj&#39;
sched = BlockingScheduler()
sched.add_job(my_job, &#39;interval&#39;, seconds=5)
sched.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;复杂的配置：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
from pymongo import MongoClient
from apscheduler.schedulers.blocking import BlockingScheduler
from apscheduler.jobstores.mongodb import MongoDBJobStore
from apscheduler.jobstores.memory import MemoryJobStore
from apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor
def my_job():
    print &#39;shanyj&#39;

host = &#39;127.0.0.1&#39;
port = 27017
client = MongoClient(host, port)

jobstores = {
&#39;mongo&#39;: MongoDBJobStore(collection=&#39;job&#39;, database=&#39;test&#39;, client=client),
&#39;default&#39;: MemoryJobStore()
}

executors = {
&#39;default&#39;: ThreadPoolExecutor(10),
&#39;processpool&#39;: ProcessPoolExecutor(3)
}

job_defaults = {
&#39;coalesce&#39;: False,
&#39;max_instances&#39;: 3
}

scheduler = BlockingScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults)
scheduler.add_job(my_job, &#39;interval&#39;, seconds=5)
try:
    scheduler.start()
except SystemExit:
    scheduler.shutdown()
    client.close()
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 07 Jul 2015 04:14:54 +0800</pubDate>
        <link>/2015/07/07/APScheduler/</link>
        <guid isPermaLink="true">/2015/07/07/APScheduler/</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Django 多数据库</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;配置数据库&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#class&quot; id=&quot;markdown-toc-class&quot;&gt;配置class&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#classsettings&quot; id=&quot;markdown-toc-classsettings&quot;&gt;将数据库class添加至settings&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;同步数据库&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#modelclass-meta&quot; id=&quot;markdown-toc-modelclass-meta&quot;&gt;model的class meta&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sql&quot; id=&quot;markdown-toc-sql&quot;&gt;使用底层sql&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;最近发现手头Django项目比较乱，一个单独的数据库貌似已经无法满足需求了，就研究下Django多数据库的配置和操作，自己试了试果然行得通！具体配置要点如下。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;配置数据库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在settings中进行配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
DATABASES = {
    #之所以这里仍然保留default数据库，是因为如果要使用Django的Auth应用或者Admin应用
    #我希望它默认将数据存放在default.db中，而不与其他数据搞混
     &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: &#39;db/default.db&#39;,
        &#39;USER&#39;: &#39;&#39;,
        &#39;PASSWORD&#39;: &#39;&#39;,
        &#39;HOST&#39;: &#39;&#39;,
        &#39;PORT&#39;: &#39;&#39;,
    },

    #提供给userApp使用
     &#39;userdb&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: &#39;db/user.db&#39;,
        &#39;USER&#39;: &#39;&#39;,
        &#39;PASSWORD&#39;: &#39;&#39;,
        &#39;HOST&#39;: &#39;&#39;,
        &#39;PORT&#39;: &#39;&#39;,
    },

     &#39;essaydb&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: &#39;db/essay.db&#39;,
        &#39;USER&#39;: &#39;&#39;,
        &#39;PASSWORD&#39;: &#39;&#39;,
        &#39;HOST&#39;: &#39;&#39;,
        &#39;PORT&#39;: &#39;&#39;,
    },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;class&quot;&gt;配置class&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;新建dbsettings.py , 编写下面 , class一般只改最后一个方法&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
class appdb(object):
    def db_for_read(self, model, **hints):
        #该方法定义读取时从哪一个数据库读取
        return self.__app_router(model)

    def db_for_write(self, model, **hints):
        #该方法定义写入时从哪一个数据库读取，如果读写分离，可再额外配置
        return self.__app_router(model)

    def allow_relation(self, obj1, obj2, **hints):
        #该方法用于判断传入的obj1和obj2是否允许关联，可用于多对多以及外键
        #同一个应用同一个数据库
        if obj1._meta.app_label == obj2._meta.app_label:
            return True
        #User和Essay是允许关联的
        elif obj1._meta.app_label in (&#39;userApp&#39;,&#39;essayApp&#39;) and obj2._meta.app_label in (&#39;userApp&#39;,&#39;essayApp&#39;):
            return True

    def allow_syncdb(self, db, model):
        #该方法定义数据库是否能和名为db的数据库同步
        return self.__app_router(model) == db

   #添加一个私有方法用来判断模型属于哪个应用，并返回应该使用的数据库
    def __app_router(self, model):
        if model._meta.app_label == &#39;userApp&#39;:
            return &#39;userdb&#39;
        elif model._meta.app_label == &#39;essayApp&#39;:
            return &#39;essaydb&#39;
        else :
            return &#39;default&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;classsettings&quot;&gt;将数据库class添加至settings&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;DATABASE_ROUTERS = [‘dbsettings.appdb’]&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;同步数据库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用下列方法分别同步不同数据库：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
python manage.py syncdb #默认同步的数据库为&#39;default&#39;
python manage.py syncdb --database=userdb  #为userdb同步数据
python manage.py syncdb --database=essaydb #为essaydb同步数据
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;反向同步数据库&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
python manage.py inspectdb --database=userdb &amp;gt; shanyjuser/models.py
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;注意database＝后面是settings里的名字&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;modelclass-meta&quot;&gt;model的class meta&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;每个model的class meta
中 app_label = ‘myapp’
应和（2）中的最后一个方法相匹配！&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;sql&quot;&gt;使用底层sql&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;除了自带的model之外还可以使用底层sql&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;针对单数据库
        &lt;pre&gt;&lt;code&gt;
from django.db import connection, transaction
    cursor = connection.cursor()
    # 数据修改操作——提交要求
    cursor.execute(&quot;UPDATE bar SET foo = 1 WHERE baz = %s&quot;, [self.baz])
    transaction.commit_unless_managed()
    # 或者 transaction.set_dirty()
    # 数据检索操作,不需要提交
    cursor.execute(&quot;SELECT foo FROM bar WHERE baz = %s&quot;, [self.baz])
    row = cursor.fetchone()
    return row
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;针对多数据库
        &lt;pre&gt;&lt;code&gt;
from django.db import connections
cursor = connections[&#39;my_db_alias&#39;].cursor()
cursor.execute(&quot;UPDATE bar SET foo = 1 WHERE baz = %s&quot;, [self.baz])
transaction.commit_unless_managed(using=&#39;my_db_alias&#39;)
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 19 Jun 2015 05:30:27 +0800</pubDate>
        <link>/2015/06/19/Django-Databases/</link>
        <guid isPermaLink="true">/2015/06/19/Django-Databases/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django django-redis 缓存</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#settings&quot; id=&quot;markdown-toc-settings&quot;&gt;settings配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;其他配置&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;需要频繁对一个字段读取的时一般会将这个字段放入到缓存服务器上，而redis就是一个很好的选择，django-redis为我们使用redis作为缓存奠定了基础&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;安装&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;安装Redis服务器端: sudo apt-get install redis-server&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;安装redis for Django的插件: pip install django-redis&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;settings&quot;&gt;settings配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在Django的settings中配置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
  CACHES = {
     &#39;default&#39;: {
         &#39;BACKEND&#39;: &#39;redis_cache.cache.RedisCache&#39;,
         &#39;LOCATION&#39;: &#39;redis://127.0.0.1:6379/1&#39;,
         &quot;OPTIONS&quot;: {
             &quot;CLIENT_CLASS&quot;: &quot;redis_cache.client.DefaultClient&quot;,
             },
         },
     }
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当时用MemcachedCache时，配置类似&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
  CACHES = {
     &#39;default&#39;: {
         &#39;BACKEND&#39;: &#39;django.core.cache.backends.memcached.MemcachedCache&#39;,
         &#39;LOCATION&#39;: &#39;127.0.0.1:11211&#39;,
         }
     }
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用方法参见 http://shanyj.github.io/2015/05/27/Django-Cache/&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;其他配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用redis作为session后台：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;SESSION_ENGINE = “django.contrib.sessions.backends.cache”      SESSION_CACHE_ALIAS = “default”&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 31 May 2015 06:04:15 +0800</pubDate>
        <link>/2015/05/31/Django-django-redis/</link>
        <guid isPermaLink="true">/2015/05/31/Django-django-redis/</guid>
        
        
        <category>Django第三方模块</category>
        
      </item>
    
      <item>
        <title>Django 缓存</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;分类&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;站点级缓存&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;视图级缓存&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;模块级缓存&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#api&quot; id=&quot;markdown-toc-api&quot;&gt;底层api&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;当需要从数据库频繁大量读取某一数据时，会导致页面反应时间大幅下降，此时可以采用缓存来进行优化，总结的缓存相关知识如下&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;分类&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;内存缓存&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;需要借助memcached或redis等&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;数据库缓存&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;需要先安装缓存表 即python manage.py createcachetable cache_table&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;文件系统缓存&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;本地缓存&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;只利用内存缓存的优势&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;仿缓存&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;仅供开发使用&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;站点级缓存&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;需要借助中间键，django.middleware.cache.UpdateCacheMiddleware，django.middleware.cache.FetchFromCacheMiddleware分别添加到中间键的第一和靠近最后位置，&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在setting中添加CACHE_MIDDLEWARE_SECONDS（每个页面缓存秒数），CACHE_MIDDLEWARE_KEY_PREFIX（可为空）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;缓存会自动缓存每个没有post和get请求的页面&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;视图级缓存&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;cache_page装饰器&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
 from django.views.decorators.cache import cache_page
 @cache_page(60 * 15)      //存900秒
 &lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在url配置页面，(r’^foo/(\d{1,2})/$’, cache_page(my_view, 60 * 15))&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;装饰头&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;@vary_on_headers(‘User‐Agent’, ‘Cookie’)：  根据User‐Agent和Cookie不同来进行分别缓存&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;@vary_on_cookie:  @vary_on_cookie＝  @vary_on_headers(‘Cookie’)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;@cache_control(private=True): 私人缓存，根据用户不同进行不同缓存&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;注意顺序&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;
@cache_page(60*2)
@vary_on_headers(&#39;User-Agent&#39;)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-4&quot;&gt;模块级缓存&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;模块级缓存&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
    { % load cache % }
    { % cache 500 sidebar % }
    { % endcache % }
 &lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;api&quot;&gt;底层api&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;底层API&lt;/p&gt;

    &lt;p&gt;cache.set(‘haha’,1,600)&lt;/p&gt;

    &lt;p&gt;cache.incr(‘haha’) //自增&lt;/p&gt;

    &lt;p&gt;cache.decr(‘haha’,10) //自减10&lt;/p&gt;

    &lt;p&gt;cache.get(‘haha’,’过期了’)  //当获取不到时返回 过期了&lt;/p&gt;

    &lt;p&gt;cache.get_many([‘haha’,’haha1’,’haha2’])  //返回多个&lt;/p&gt;

    &lt;p&gt;cache.delete(‘a’)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 28 May 2015 05:58:09 +0800</pubDate>
        <link>/2015/05/28/Django-Cache/</link>
        <guid isPermaLink="true">/2015/05/28/Django-Cache/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django 国际化</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#py&quot; id=&quot;markdown-toc-py&quot;&gt;py文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;模板代码&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;消息文件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;语言偏好&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;重定向视图&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;Django有一套规范的国际化和本地化方法，可以方便世界各的用户使用产品，国际化和本地化使用方法如下&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;py&quot;&gt;py文件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ugettext()&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;使用ugettext() 函数指定要翻译的字符串，惯例用_代替&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;示例：&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
    &lt;pre&gt;&lt;code&gt;
 from django.utils.translation import ugettext as _
 def translate(request):
     a = _(&#39;Today is %(month)s %(day)s.&#39;) % {&#39;month&#39;: m, &#39;day&#39;: d}
     return HttpResponse(a)
&lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gettext_noop()&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;标记字符串为不翻译&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;django.utils.translation.gettext_noop(),这种情况下会以原始语言存在数据库等地，只在最后展示给用户时翻译&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;gettext_lazy()&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;惰性翻译&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;django.utils.translation.gettext_lazy(),只有当值被访问时才翻译，而不是在gettext_lazy()调用时翻译，同样在数据库等地都不翻译&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;django模型中都使用惰性翻译&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;a=u”Hello %s” % ugettext_lazy(“people”),可以进行unicode插入&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ungettext()&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;指定复数形势&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用django.utils.translation.ungettext()，有三个参数：1.单数形式字符串翻译，2.复数形式的字符串翻译，3.对象的个数&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;模板代码&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;trans翻译&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;{ % load i18n % }放在最前面，然后使用{ % trans “pingshen” % }&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;blocktrans翻译&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;{ % blocktrans % }This string will have { { value } } inside.{ % endblocktrans % }&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;消息文件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;django‐admin.py makemessages ‐l de ‐e html,txt ‐e xml    de为语言代码、-e为需要翻译的文件类型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;脚本在django根目录 or 项目根目录 or 应用根目录下执行。需要手动创建locale文件夹。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编辑.po文件，msgid “”      msgstr “” 分别表示翻译前和翻译后的文字&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;django‐admin.py makemessages ‐a更新语言信息，django‐admin.py compilemessages 编译语言信息&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;语言偏好&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当使用locatemiddleware django.middleware.locale.LocaleMiddleware中间键时， 中间件查找顺序 session的django_language、cookie、http请求头、settings中的language code&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;LANGUAGES = ((‘en’, u’English’),(‘zh-cn’,u’中文’))设置可选语种&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-4&quot;&gt;重定向视图&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;url中(r’^i18n/’, include(‘django.conf.urls.i18n’))，使得 /i18n/setlang/有效&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择语言时，如果session启动，视图会将语言选择保存在session中，否则以django-language为key保存在cookie中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;选择完语言后，重定向到post的&amp;lt; input name=”next” &amp;gt;值中，或者html头的refer中，再或者/&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 &amp;lt; form action=&quot;/i18n/setlang/&quot; method=&quot;post&quot; &amp;gt;
     &amp;lt; input name=&quot;next&quot; type=&quot;hidden&quot; value=&quot;/next/page/&quot;  &amp;gt;
     &amp;lt; select name=&quot;language&quot; &amp;gt;
     { % for lang in LANGUAGES % }
     &amp;lt; option value=&quot;&quot; &amp;gt; { { lang.1 } } &amp;lt;/ option &amp;gt;
     { % endfor % }
     &amp;lt; /select &amp;gt;
     &amp;lt; input type=&quot;submit&quot; value=&quot;Go&quot;  &amp;gt;
 &amp;lt; /form &amp;gt;
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 May 2015 04:12:35 +0800</pubDate>
        <link>/2015/05/25/Django-Local/</link>
        <guid isPermaLink="true">/2015/05/25/Django-Local/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django 整合数据库</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#inspectdb&quot; id=&quot;markdown-toc-inspectdb&quot;&gt;inspectdb&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;注意事项&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;当尝试用Django来重构某一项目时，数据资源的整合十分关键，下面就介绍一下Django是如何进行数据库整合的&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;inspectdb&quot;&gt;inspectdb&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;inspectdb命令可以依据数据库结构来生成新的model&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;python mysite/manage.py inspectdb &amp;gt; mysite/myapp/models.py 重定向输出到models.py&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;如：python manage.py inspectdb &amp;gt; models.py&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;注意事项&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;命令不会自动转换manytomany类型&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当没有主键时自动增加id = models.IntegerField(primary_key=True)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;无法检测类型时会用textfield代替&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果列名为django保留字，会做下面处理，以for为例：for_field = models.IntegerField(db_column=’for’), 添加_field 并且db_column设置为原来名字&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要手动调节一下model的顺序，比如某一个model引用了另一个model外键，另一个要在前面&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 21 May 2015 05:02:22 +0800</pubDate>
        <link>/2015/05/21/Django-Rebuild-db/</link>
        <guid isPermaLink="true">/2015/05/21/Django-Rebuild-db/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django 安全</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#sql&quot; id=&quot;markdown-toc-sql&quot;&gt;sql注入&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#xss&quot; id=&quot;markdown-toc-xss&quot;&gt;跨站点脚本xss&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#csrf&quot; id=&quot;markdown-toc-csrf&quot;&gt;伪造跨站点请求csrf&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;邮件头部注入&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;暴露错误消息&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;伪造会话&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;安全是在进行项目开发时需要处处注意的问题，下面就总结下Django常见的安全问题的解决方法&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;sql&quot;&gt;sql注入&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;为了防止sql注入，Django总是对输入进行自动转义&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当直接使用sql语句时，注意使用sql占位符&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 def user_contacts(request):
     user = request.GET[&#39;username&#39;]
     sql = &quot;SELECT * FROM user_contacts WHERE username = %s&quot;
     cursor = connection.cursor()
     cursor.execute(sql, [user])
 &lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;execute有第二个参数，包含若干占位符，来对sql语句中的占位符赋值，过程中会自动转义&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;xss&quot;&gt;跨站点脚本xss&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在url中进行修改，比如http://example.com/hello/?name=&lt;i&gt;Jacob&lt;/i&gt;  会返回&amp;lt;h1&amp;gt;Hello, &lt;i&gt;Jacob&lt;/i&gt;!&amp;lt;/h1&amp;gt;, 因此可以在url中写上jquery语句来操作数据库&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为此，django总是自动转义&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;csrf&quot;&gt;伪造跨站点请求csrf&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在登陆信任网站且没退出时访问危险网站，导致cookie被盗用,比如在危险网站中插入　&amp;lt;img src=http://www.mybank.com/Transfer.php?toBankId=11&amp;amp;money=1000&amp;gt; 这个get／post请求，只要点击银行账户就少钱了！&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为此，django添加了csrf中间键&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;只针对post请求，get请求需要设计者自己保证没有副作用&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;django.contrib.csrf.middleware.CsrfMiddleware放在中间件中，且在session之后在 GZipMiddleware 之前&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;只有 Content‐Type头部标记为text/html ，application/xml+xhtml的页面才会被保护&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;向所有post表单增加隐藏字段，名称为csrfmiddlewaretoken，值为当前会话id加秘钥&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;对传入的post检查csrfmiddlewaretoken，如不正确或不存在则403&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;仅限于常规方法创建的表单&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;邮件头部注入&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在构建邮件sunject时加上hello\ncc:spamvictim@example.com”（\n是换行符）
 就会变成:&lt;/p&gt;

    &lt;p&gt;To: hardcoded@example.com Subject: hello&lt;/p&gt;

    &lt;p&gt;cc: spamvictim@example.com&lt;/p&gt;

    &lt;p&gt;从而利用了别人的邮箱来发送了信息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为此，django自带的django.core.mail 中不允许出现换行符,且总是自动转义&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;暴露错误消息&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Django的出错页面总是很详尽的列出出错的原因和代码，容易将内部代码很容易的暴露出去&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;关闭debug&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;伪造会话&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;中间人攻击：监听所有网络&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;伪造会话：利用会话id将自己伪造成用户&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;解决：django会话id存在哈西表中，且用户去访问不存在的会话id时会生成新会话id）&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;伪造cookie和会话滞留：获取url中的session来进行盗用&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;解决：首先不要再url中包含session（django自带，只有映射用的session id），不在cookie存数据&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 18 May 2015 05:02:22 +0800</pubDate>
        <link>/2015/05/18/Django-Security/</link>
        <guid isPermaLink="true">/2015/05/18/Django-Security/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django 简单页面&amp;重定向&amp;个性化设置</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;简单页面&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;重定向&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;个性化数据&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;Django简单页面可以用来进行声明、条款等几乎不许改变内容的页面渲染，重定向负责页面重定向，人性化设置则是为了显示更美观&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;简单页面&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;激活简单页面&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;添加‘django.contrib.sites’，’django.contrib.flatpages’到INSTALLED_APPS&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;添加’django.contrib.flatpages.middleware.FlatpageFallbackMiddleware’到MIDDLEWARE_CLASSES，通常放在列表最后，因为是最后的办法&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;运行python manage.py syncdb生成简单页面表&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;简单页面model&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 class FlatPage(models.Model):
     url = models.CharField(max_length=100, db_index=True)
     title = models.CharField(max_length=200)
     content = models.TextField(blank=True)
     enable_comments = models.BooleanField()
     template_name = models.CharField(max_length=70, blank=True)
     registration_required = models.BooleanField()
     sites = models.ManyToManyField(Site)
 &lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;url：不包含域名，如/about/contact/&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;title：标题&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;content：网页内容&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;enable_comments：是否允许评论&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;template_name：模版名称，如果未知定，则使用flatpages/default.html&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;registration_required：是否需要登陆&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;最后渲染指定template即可，以title为例&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;重定向&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;激活重定向&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;将’django.contrib.redirects’加到INSTALLED_APPS&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;将’django.contrib.redirects.middleware.RedirectFallbackMiddleware’加到MIDDLEWARE_CLASSES&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;运行python manage.py syncdb生成重定向表&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置model&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;重定向model比较简单，只有site、oldpath、newpath三个属性&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;个性化数据&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;激活个性化数据&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;将django.contrib.humanize加入app中&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;使用个性化数据&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;使用前需要进行调用{ % load humanize % }&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用apnumber：{ {1|apnumber} }（1 变成 one ）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用intcomma：{ {1000000|intcomma} }（4500 变成 4,500）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用intword：{ {1000000000000|intword} }（1000000 变成 1.0 million ）&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用ordinal：{ {1|ordinal} }（1 变成 1st ）&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Sat, 16 May 2015 03:58:09 +0800</pubDate>
        <link>/2015/05/16/Django-Flatpage/</link>
        <guid isPermaLink="true">/2015/05/16/Django-Flatpage/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django Site多站点</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#site&quot; id=&quot;markdown-toc-site&quot;&gt;添加Site&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#model&quot; id=&quot;markdown-toc-model&quot;&gt;定义model&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;取数据&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#currentsitemanager&quot; id=&quot;markdown-toc-currentsitemanager&quot;&gt;CurrentSiteManager&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;自动判断&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;本文主要介绍Django多站点的使用和一些注意事项&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;site&quot;&gt;添加Site&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先需要进行安装，在settings中INSTALL_APP添加django.contrib.sites，并生成对应的表&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;每个Site对象都具有name和domain，在表中添加对应的site实例即可&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在不同站点的settings中添加SITE_ID为指定的site的id号即可&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;model&quot;&gt;定义model&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当具有site时，就可以定义含有site多对多类型的model&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 class ok(models.Model):
     headline = models.CharField(max_length=200)
     sites = models.ManyToManyField(Site)
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;取数据&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当从含有site这个field的model中取数据时，就可以只去与本站相关联的数据了&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 from django.conf import settings
 from books.models import ok

 def ok1(request):
     a=ok.objects.filter(site__id=settings.SITE_ID)
     return HttpResponse(a)
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;currentsitemanager&quot;&gt;CurrentSiteManager&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;CurrentSiteManager可以自动过滤当前site_id的信息&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 class Photo(models.Model):
     photo = models.FileField(upload_to=&#39;/home/photos&#39;)
     site = models.ForeignKey(Site)
     objects = models.Manager()
     on_site = CurrentSiteManager()
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;按照上面的代码，Photo.objects.filter(site__id=settings.SITE_ID)和Photo.on_site.all()等价&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当model中对应的外键名字不为site时，使用on_site = CurrentSiteManager(‘publish_on’)来指定&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;自动判断&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;current_site = Site.objects.get_current()可以取出当前站点的site&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 current_site = Site.objects.get_current()
 if current_site.domain == &#39;foo.com&#39;:
      # Do something
 else:
      # Do something else.
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 13 May 2015 05:11:42 +0800</pubDate>
        <link>/2015/05/13/Django-Site/</link>
        <guid isPermaLink="true">/2015/05/13/Django-Site/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django 中间键</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;顺序&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;例子&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;中间键，顾名思义，就是在处理一个Request前后需要执行的一系列函数，以下就是对Django中间键的一些总结&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;顺序&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Django中间键执行顺序为，在request和view阶段从上到下处理，response和异常处理阶段从下到上处理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;settings中MIDDLEWARE_CLASSES包含了当前使用的中间键&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;init&lt;/strong&gt;(self)：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只在django运行时加载一次，如果抛出异常则将该中间件剔除，不对每个request单独处理，只需要self参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;process_request(self,request)：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在接受request后并且view函数运行前执行的，应返回None或者Httpresponse对象，如果返回None继续执行view函数，返回Httpresponse则不执行view函数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;process_view(self,request,view,args,kwargs)：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中args和kwargs是将传入view的参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;process_response(self,request,response)：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;view函数执行response之后，必须返回httpresponse对象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;process_exception(self,request,exception)：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;view函数执行时抛出异常才会进行处理&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;例子&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
 class MultiHostMiddleware:
    def process_request(self, request):
        try:
            host = request.user
            if host == &#39;shanyj&#39;:
                return HttpResponse(&#39;aaaaa&#39;)
            response=HttpResponse(&#39;haha&#39;)
            response.set_cookie(&#39;favorite_color&#39;,&#39;lala&#39;)
            return response
        except KeyError:
            pass
    def process_response(self, request, response):
        try:
            if request.COOKIES[&#39;favorite_color&#39;]:
                return response
        except:
            return response
        else:
            return response
 &lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 10 May 2015 04:18:33 +0800</pubDate>
        <link>/2015/05/10/Django-MiddleClass/</link>
        <guid isPermaLink="true">/2015/05/10/Django-MiddleClass/</guid>
        
        
        <category>Django</category>
        
      </item>
    
  </channel>
</rss>
