<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ShanYJ</title>
    <description>╭(╯^╰)╮吉吉的博客</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 09 Dec 2015 13:51:34 +0800</pubDate>
    <lastBuildDate>Wed, 09 Dec 2015 13:51:34 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Python APScheduler定时任务框架</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;组件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;原则&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;常用方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;三种调度&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;时间格式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-7&quot; id=&quot;markdown-toc-section-7&quot;&gt;案例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;之前的Django文档管理系统项目中，有文件设置过期时间的功能，其中删除是通过celery定时任务每日凌晨来实现的，今天回过头又找了找定时任务，发现了一个及其简便的定时任务框架：APScheduler。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;安装&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;pip install apscheduler&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;组件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;触发器(trigger)&lt;/strong&gt;:包含调度逻辑，每一个作业有它自己的触发器，用于决定接下来哪一个作业会运行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作业存储(job store)&lt;/strong&gt;:存储被调度的作业，默认的作业存储是简单地把作业保存在内存中，其他的作业存储是将作业保存在数据库中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;执行器(executor)&lt;/strong&gt;:处理作业的运行，他们通常通过在作业中提交制定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;调度器(scheduler)&lt;/strong&gt;:是其他的组成部分。你通常在应用只有一个调度器，应用的开发者通常不会直接处理作业存储、调度器和触发器，相反，调度器提供了处理这些的合适的接口。配置作业存储和执行器可以在调度器中完成，例如添加、修改和移除作业。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;调度器选择&lt;/strong&gt;:这取决于你的应用环境和你使用APScheduler的目的。通常最常用的两个：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;–BlockingScheduler: 当调度器是你应用中唯一要运行的东西时使用。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;–BackgroundScheduler: 当你不运行任何其他框架时使用，并希望调度器在你应用的后台执行。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作业存储选择&lt;/strong&gt;:你需要决定是否需要作业持久化。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;如果你总是在应用开始时重建job，你可以直接使用默认的作业存储（MemoryJobStore).&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果你需要将你的作业持久化，以避免应用崩溃和调度器重启时，你可以根据你的应用环境来选择具体的作业存储。例如：使用Mongo或者SQLAlchemyJobStore （用于支持大多数RDBMS）&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;执行器选择&lt;/strong&gt;:通常有两种:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;默认为ThreadPoolExecutor 通常用于大多数用途。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果你的工作负载中有较大的CPU密集型操作，你可以考虑用ProcessPoolExecutor来使用更多的CPU核。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;你也可以在同一时间使用两者，将进程池调度器作为第二执行器。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-4&quot;&gt;常用方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;添加作业&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;使用add_job():
scheduler.add_job(myfunc, ‘interval’, minutes=2)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用装饰器：@sched.scheduled_job(‘cron’, id=’my_job_id’, day=’last sun’)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;add_job的第二个参数是trigger，它管理着作业的调度方式。它可以为date, interval或者cron。对于不同的trigger，对应的参数也相同。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;移除作业&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;scheduler.remove_job(‘my_job_id’)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;暂停和继续作业&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;apscheduler.schedulers.base.BaseScheduler.pause_job()
apscheduler.schedulers.base.BaseScheduler.resume_job()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;获得job列表&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;scheduler.get_jobs()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;关闭调度器&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;scheduler.shutdown(wait=False)
默认情况下调度器会等待所有正在运行的作业完成后，关闭所有的调度器和作业存储。如果你不想等待，可以将wait选项设置为False。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-5&quot;&gt;三种调度&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;cron  定时调度&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;year: 4位数字&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;month: 月 (1-12)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;day: 天 (1-31)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;week: 标准周 (1-53)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;day_of_week: 周中某天 (0-6 or mon,tue,wed,thu,fri,sat,sun)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;hour: 小时 (0-23)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;minute:分钟 (0-59)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;second: 秒 (0-59)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;start_date: 最早执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;end_date: 最晚执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;timezone: 执行时间区间&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;interval  间隔调度&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;weeks: 每隔几周执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;days: 每隔几天执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;hours: 每隔几小时执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;minutes: 每隔几分执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;seconds: 每隔几秒执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;start_date: 最早执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;end_date: 最晚执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;timezone: 执行时间区间&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;date  定时调度&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;最基本的一种调度，作业只会执行一次。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;run_date: 在某天执行任务&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;timezone: 在某段时间执行任务&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-6&quot;&gt;时间格式&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Expression	Field	Description
*	         any	Fire on every value
*/a	         any	Fire everyavalues, starting from the minimum
a-b	         any	Fire on any value within thea-brange (a must be smaller than b)
a-b/c	     any	Fire everycvalues within thea-brange
xthy	     day	Fire on thex-th occurrence of weekdayywithin the month
lastx	     day	Fire on the last occurrence of weekdayxwithin the month
last	     day	Fire on the last day within the month
x,y,z	     any	Fire on any matching expression
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-7&quot;&gt;案例&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;可以先创建调度器，再配置和添加作业，这样你可以在不同的环境中得到更大的灵活性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面是一个简单使用BlockingScheduler，并使用默认内存存储和默认执行器。
(默认选项分别是MemoryJobStore和ThreadPoolExecutor，其中线程池的最大线程数为10)。配置完成后使用start()方法来启动。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
def my_job():
    print &#39;shanyj&#39;
sched = BlockingScheduler()
sched.add_job(my_job, &#39;interval&#39;, seconds=5)
sched.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;复杂的配置：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
from pymongo import MongoClient
from apscheduler.schedulers.blocking import BlockingScheduler
from apscheduler.jobstores.mongodb import MongoDBJobStore
from apscheduler.jobstores.memory import MemoryJobStore
from apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor
def my_job():
    print &#39;shanyj&#39;

host = &#39;127.0.0.1&#39;
port = 27017
client = MongoClient(host, port)

jobstores = {
&#39;mongo&#39;: MongoDBJobStore(collection=&#39;job&#39;, database=&#39;test&#39;, client=client),
&#39;default&#39;: MemoryJobStore()
}

executors = {
&#39;default&#39;: ThreadPoolExecutor(10),
&#39;processpool&#39;: ProcessPoolExecutor(3)
}

job_defaults = {
&#39;coalesce&#39;: False,
&#39;max_instances&#39;: 3
}

scheduler = BlockingScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults)
scheduler.add_job(my_job, &#39;interval&#39;, seconds=5)
try:
    scheduler.start()
except SystemExit:
    scheduler.shutdown()
    client.close()
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 07 Jul 2015 04:14:54 +0800</pubDate>
        <link>/2015/07/07/APScheduler/</link>
        <guid isPermaLink="true">/2015/07/07/APScheduler/</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Django 多数据库</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;配置数据库&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#class&quot; id=&quot;markdown-toc-class&quot;&gt;配置class&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#classsettings&quot; id=&quot;markdown-toc-classsettings&quot;&gt;将数据库class添加至settings&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;同步数据库&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#modelclass-meta&quot; id=&quot;markdown-toc-modelclass-meta&quot;&gt;model的class meta&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sql&quot; id=&quot;markdown-toc-sql&quot;&gt;使用底层sql&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;最近发现手头Django项目比较乱，一个单独的数据库貌似已经无法满足需求了，就研究下Django多数据库的配置和操作，自己试了试果然行得通！具体配置要点如下。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;配置数据库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在settings中进行配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
DATABASES = {
    #之所以这里仍然保留default数据库，是因为如果要使用Django的Auth应用或者Admin应用
    #我希望它默认将数据存放在default.db中，而不与其他数据搞混
     &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: &#39;db/default.db&#39;,
        &#39;USER&#39;: &#39;&#39;,
        &#39;PASSWORD&#39;: &#39;&#39;,
        &#39;HOST&#39;: &#39;&#39;,
        &#39;PORT&#39;: &#39;&#39;,
    },

    #提供给userApp使用
     &#39;userdb&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: &#39;db/user.db&#39;,
        &#39;USER&#39;: &#39;&#39;,
        &#39;PASSWORD&#39;: &#39;&#39;,
        &#39;HOST&#39;: &#39;&#39;,
        &#39;PORT&#39;: &#39;&#39;,
    },

     &#39;essaydb&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: &#39;db/essay.db&#39;,
        &#39;USER&#39;: &#39;&#39;,
        &#39;PASSWORD&#39;: &#39;&#39;,
        &#39;HOST&#39;: &#39;&#39;,
        &#39;PORT&#39;: &#39;&#39;,
    },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;class&quot;&gt;配置class&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;新建dbsettings.py , 编写下面 , class一般只改最后一个方法&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
class appdb(object):
    def db_for_read(self, model, **hints):
        #该方法定义读取时从哪一个数据库读取
        return self.__app_router(model)

    def db_for_write(self, model, **hints):
        #该方法定义写入时从哪一个数据库读取，如果读写分离，可再额外配置
        return self.__app_router(model)

    def allow_relation(self, obj1, obj2, **hints):
        #该方法用于判断传入的obj1和obj2是否允许关联，可用于多对多以及外键
        #同一个应用同一个数据库
        if obj1._meta.app_label == obj2._meta.app_label:
            return True
        #User和Essay是允许关联的
        elif obj1._meta.app_label in (&#39;userApp&#39;,&#39;essayApp&#39;) and obj2._meta.app_label in (&#39;userApp&#39;,&#39;essayApp&#39;):
            return True

    def allow_syncdb(self, db, model):
        #该方法定义数据库是否能和名为db的数据库同步
        return self.__app_router(model) == db

   #添加一个私有方法用来判断模型属于哪个应用，并返回应该使用的数据库
    def __app_router(self, model):
        if model._meta.app_label == &#39;userApp&#39;:
            return &#39;userdb&#39;
        elif model._meta.app_label == &#39;essayApp&#39;:
            return &#39;essaydb&#39;
        else :
            return &#39;default&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;classsettings&quot;&gt;将数据库class添加至settings&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;DATABASE_ROUTERS = [‘dbsettings.appdb’]&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;同步数据库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用下列方法分别同步不同数据库：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
python manage.py syncdb #默认同步的数据库为&#39;default&#39;
python manage.py syncdb --database=userdb  #为userdb同步数据
python manage.py syncdb --database=essaydb #为essaydb同步数据
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;反向同步数据库&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
python manage.py inspectdb --database=userdb &amp;gt; shanyjuser/models.py
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;注意database＝后面是settings里的名字&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;modelclass-meta&quot;&gt;model的class meta&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;每个model的class meta
中 app_label = ‘myapp’
应和（2）中的最后一个方法相匹配！&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;sql&quot;&gt;使用底层sql&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;除了自带的model之外还可以使用底层sql&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;针对单数据库
        &lt;pre&gt;&lt;code&gt;
from django.db import connection, transaction
    cursor = connection.cursor()
    # 数据修改操作——提交要求
    cursor.execute(&quot;UPDATE bar SET foo = 1 WHERE baz = %s&quot;, [self.baz])
    transaction.commit_unless_managed()
    # 或者 transaction.set_dirty()
    # 数据检索操作,不需要提交
    cursor.execute(&quot;SELECT foo FROM bar WHERE baz = %s&quot;, [self.baz])
    row = cursor.fetchone()
    return row
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;针对多数据库
        &lt;pre&gt;&lt;code&gt;
from django.db import connections
cursor = connections[&#39;my_db_alias&#39;].cursor()
cursor.execute(&quot;UPDATE bar SET foo = 1 WHERE baz = %s&quot;, [self.baz])
transaction.commit_unless_managed(using=&#39;my_db_alias&#39;)
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 19 Jun 2015 05:30:27 +0800</pubDate>
        <link>/2015/06/19/Django-Databases/</link>
        <guid isPermaLink="true">/2015/06/19/Django-Databases/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django 中间键</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;顺序&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;例子&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;中间键，顾名思义，就是在处理一个Request前后需要执行的一系列函数，以下就是对Django中间键的一些总结&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;顺序&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Django中间键执行顺序为，在request和view阶段从上到下处理，response和异常处理阶段从下到上处理&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;settings中MIDDLEWARE_CLASSES包含了当前使用的中间键&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;init&lt;/strong&gt;(self)：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只在django运行时加载一次，如果抛出异常则将该中间件剔除，不对每个request单独处理，只需要self参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;process_request(self,request)：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在接受request后并且view函数运行前执行的，应返回None或者Httpresponse对象，如果返回None继续执行view函数，返回Httpresponse则不执行view函数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;process_view(self,request,view,args,kwargs)：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;其中args和kwargs是将传入view的参数&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;process_response(self,request,response)：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;view函数执行response之后，必须返回httpresponse对象&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;process_exception(self,request,exception)：&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;view函数执行时抛出异常才会进行处理&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;例子&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;
 class MultiHostMiddleware:
    def process_request(self, request):
        try:
            host = request.user
            if host == &#39;shanyj&#39;:
                return HttpResponse(&#39;aaaaa&#39;)
            response=HttpResponse(&#39;haha&#39;)
            response.set_cookie(&#39;favorite_color&#39;,&#39;lala&#39;)
            return response
        except KeyError:
            pass
    def process_response(self, request, response):
        try:
            if request.COOKIES[&#39;favorite_color&#39;]:
                return response
        except:
            return response
        else:
            return response
 &lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sun, 10 May 2015 04:18:33 +0800</pubDate>
        <link>/2015/05/10/Django-MiddleClass/</link>
        <guid isPermaLink="true">/2015/05/10/Django-MiddleClass/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django 输出非Html内容</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#stringio&quot; id=&quot;markdown-toc-stringio&quot;&gt;StringIO&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pdf&quot; id=&quot;markdown-toc-pdf&quot;&gt;输出PDF&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#csv&quot; id=&quot;markdown-toc-csv&quot;&gt;输出CSV&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;实际项目中，通常需要输出非Html内容，比如下载页自动下载等，于是对Django输出非Html内容做了小结。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;stringio&quot;&gt;StringIO&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;StringIO经常被用来作为字符串的缓存，因为StringIO有个好处，他的有些接口和文件操作是一致的，也就是说用同样的代码，可以同时当成文件操作或者StringIO操作。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 temp=StringIO()
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pdf&quot;&gt;输出PDF&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;StringIO经常被用来作为字符串的缓存，因为StringIO有个好处，他的有些接口和文件操作是一致的，也就是说用同样的代码，可以同时当成文件操作或者StringIO操作。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输出非Html内容时，需要对response的mimetype和Content-Disposition进行一些修改。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;输出PDF需要使用canvas来进行内容写入和保存&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 from reportlab.pdfgen import canvas

 def showpdf(request):
     reponse=HttpResponse(mimetype=&#39;application/pdf&#39;)
     reponse[&#39;Content-Disposition&#39;]=&#39;attachment;filename=a.pdf&#39;

     temp=StringIO()

     p=canvas.Canvas(temp)
     p.drawString(800,800,&#39;asdhafuhnsdfn&#39;)
     p.showPage()
     p.save()

     response.write(temp.getvalue())
     return response
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;csv&quot;&gt;输出CSV&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;输出其他内容的方法与PDF类似，只需要进行稍微的修改即可，以CSV为例，不在使用canvas，而使用如下代码
    &lt;pre&gt;&lt;code&gt;
 writer=csv.writer(temp)
 writer.writerow([&#39;aaaaaaaaaa&#39;,&#39;bbbbbbbbbbb&#39;])
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 07 May 2015 05:12:21 +0800</pubDate>
        <link>/2015/05/07/Django-Ootput/</link>
        <guid isPermaLink="true">/2015/05/07/Django-Ootput/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django GenericForeignKey</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#model&quot; id=&quot;markdown-toc-model&quot;&gt;model&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#model-1&quot; id=&quot;markdown-toc-model-1&quot;&gt;中间model&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;存储&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;最近在项目的一个工作流流程中大量的使用到了GenericForeignKey和 Content Type，主要用于在两个model之间建立一个关联的model，于是做了如下的小结。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;model&quot;&gt;model&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;首先我们需要定义两个需要关联的model&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 from django.contrib.contenttypes import generic
 class music(models.Model):
     music_url = models.CharField(max_length=20)
     events = generic.GenericRelation(&#39;owner&#39;)
     #加这句的目的是在该实例删除时owner中的记录也会删除

 class vedio(models.Model):
     video_url = models.CharField(max_length=20)
     events = generic.GenericRelation(&#39;owner&#39;)
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;model-1&quot;&gt;中间model&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;建立与两个model建立联系的新的model&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
class owner(models.Model):
     user = models.ForeignKey(User)
     content_type = models.ForeignKey(ContentType)
     object_id = models.PositiveIntegerField()
     event_object = generic.GenericForeignKey(&#39;content_type&#39;, &#39;object_id&#39;)
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;通俗一点的理解，content_type定位了一个表，而object_id定位了一个id，event_object就相当于将’content_type’, ‘object_id’结合起来从而定位了一个model中的实例&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;存储&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;之前讲过Django的signal，django.db.models.signals.pre_save &amp;amp; django.db.models.signals.post_save分别在一个Model的save()方法之前和之后触发，我们可以应用这个来实现自动存储&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 from django.db.models.signals import post_save

 def save_owner(sender, instance, **kwargs):
     obj = instance
     publisher=User.objects.all()[0]
     event = owner(user=publisher,event_object=obj)
     event.save()

 post_save.connect(save_owner,sender=music)
 post_save.connect(save_owner,sender=vedio)
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 05 May 2015 03:32:29 +0800</pubDate>
        <link>/2015/05/05/Django-GenericForeignKey/</link>
        <guid isPermaLink="true">/2015/05/05/Django-GenericForeignKey/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django Signal 信号机制</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#signal&quot; id=&quot;markdown-toc-signal&quot;&gt;Signal类&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;发送信号&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;接受信号&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;参数获取&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;django 包含一个信号机制,用来链接框架中发生的事件与得到通知的应用之间的逻辑。简单地说, 在特定事件发生时, 使用signal发送者能够通知一系列接收者(一个或者多个)来进行相应的操作。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;signal&quot;&gt;Signal类&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用Signal前我们需要实例化一个Signal实例&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 from django.dispatch import Signal
 signalshan=Signal(providing_args=[&#39;shanyj&#39;])
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;发送信号&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;当需要通知接受者时，首先需要发送者来发送Signal&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在某方法中尽心信号发送使用了send（）方法，同事发送需要传递的格外信息&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 def shanyjsignal(request,hello=&#39;none&#39;):
     a=&#39;shanyj&#39;
     signalshan.send(sender=object,shanyj=a)
     # send方法第一个参数为sender，可以为对象.__class__ ,self（在类中的方法才可以）,或者直接写类名
     return HttpResponse(request.user)
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;接受信号&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;接受信号时，需要与某一特定函数进行绑定，大致有两种方法&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;使用装饰器：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;
 from django.dispatch import receiver

 @receiver(signalshan)
 def what(sender,shanyj,**kwargs):
     #执行函数第一个参数为sender
     print shanyj
  &lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;使用connect方法：&lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;
 signalshan.connect(what)
 #可以加第二个参数，只接受该类的sender
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;参数获取&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;参数可以通过**kwargs来进行获取&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
  upload_file_successful.send(sender=None,
                                    repo_id=repo_id,
                                    file_path=file_path,
                                    owner=owner)
    @receiver(upload_file_successful)
    def add_upload_file_msg_cb(sender, **kwargs):
        repo_id = kwargs.get(&#39;repo_id&#39;, None)
        file_path = kwargs.get(&#39;file_path&#39;, None)
        owner = kwargs.get(&#39;owner&#39;, None)
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Sat, 02 May 2015 04:24:41 +0800</pubDate>
        <link>/2015/05/02/Django-Signal/</link>
        <guid isPermaLink="true">/2015/05/02/Django-Signal/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django User扩展</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#user&quot; id=&quot;markdown-toc-user&quot;&gt;查看User类&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#abstractuser&quot; id=&quot;markdown-toc-abstractuser&quot;&gt;AbstractUser&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#abstractbaseuser&quot; id=&quot;markdown-toc-abstractbaseuser&quot;&gt;AbstractBaseUser&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#user-profile&quot; id=&quot;markdown-toc-user-profile&quot;&gt;User Profile&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;之前更改登录验证模式时返回的时Django自带的User model，当需要扩展业务而User model已经无法满足要求时，就需要扩展User类，收集后发现大致有三种方法进行User扩展。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;user&quot;&gt;查看User类&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用get_user_model()可以查看使用的user类&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在Django shell中执行下列代码，即可查看当前使用的User类&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
  from django.contrib.auth import get_user_model
  get_user_model()
   &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;abstractuser&quot;&gt;AbstractUser&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用AbstractUser可以在使用Django自带的User类的所有属性前提下进行扩展，具体使用方法如下&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;继承AbstractUser并增加新属性&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
  from django.contrib.auth.models import AbstractUser
  class NewUser(AbstractUser):
      shanyj = models.CharField(max_length=100)
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在settings中进行设置，AUTH_USER_MODEL = “myapp.NewUser”&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;为了在admin界面中，方便使用，可在对应app的admin.py中加入&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 from .models import NewUser
 admin.site.register(NewUser)
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;abstractbaseuser&quot;&gt;AbstractBaseUser&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;AbstractBaseUser对User类进行了精简，只含有3个field: password, last_login和is_active. 如果你对django user model默认的first_name, last_name不满意, 或者只想保留默认的密码储存方式, 则可以选择这一方式.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AbstractBaseUser需要编写User model和UserManager方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;User model需要注意一下几点:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;设置UserManager objects = UserManager()，UserManager()编写方法稍后介绍&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;设置USERNAME_FIELD，并且Field要有unique＝True&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;设置get_full_name()方法&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;设置get_short_name()方法&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;
     class NextUser(AbstractBaseUser):
         shanyj = models.CharField(max_length=100,unique=True)
         a = models.CharField(max_length=25)
         is_active = models.BooleanField(default=True)
         is_staff = models.BooleanField(default=True)
         is_admin = models.BooleanField(default=False)

         objects = UserManager()

         USERNAME_FIELD = &#39;shanyj&#39;

         def get_full_name(self):
             return self.shanyj
         def get_short_name(self):
             return self.shanyj
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;UserManager中需要重写两个方法，注意以下几点：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;save()用到了using=self.db&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;需要有user.set_password(password)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;user = self.model(shanyj=shanyj，…………)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要编写create_user和create_superuser方法&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 class UserManager(BaseUserManager):
     def create_user(self, shanyj, password=None):
         if not shanyj:
           raise ValueError(&#39;Users must have an email address&#39;)
         user = self.model(
           shanyj=shanyj,
         )
         user.set_password(password)
         user.save(using=self._db)
         return user

     def create_superuser(self, shanyj, password=None):
         user = self.create_user(shanyj,password)
         user.is_admin = True
         user.save(using=self._db)
         return user

 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在settings中进行设置，AUTH_USER_MODEL = “myapp.NewUser”&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;user-profile&quot;&gt;User Profile&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;使用外键的方式来对用户的属性进行扩展，增加新的model如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 class EasterProfile(models.Model):
     user = models.OneToOneField(settings.AUTH_USER_MODEL)
     favorite_ice_cream = models.ForeignKey(Flavor, null=True, blank=True
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;我们可以使用user.easterprofile.favorite_ice_cream获取相应的profile (注意为小写)&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Wed, 29 Apr 2015 04:57:51 +0800</pubDate>
        <link>/2015/04/29/Django-User/</link>
        <guid isPermaLink="true">/2015/04/29/Django-User/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django Auth登陆认证</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#model&quot; id=&quot;markdown-toc-model&quot;&gt;model&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;认证函数&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;配置&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;另一种方法&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;之前研究了登录和登出逻辑，但是具体登陆处理函数没有给出，当不仅仅满足于Django自带的登录函数功能时，需要重写验证模式，自己研究并试用了下，暂时只更改改验证模式，而不更改user的属性，具体方式如下：&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;model&quot;&gt;model&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;我们使用新的model来进行用户验证，而代替Django自带的User model&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在任意app的model中加入新的账户类如account1类，同时定义一个类中的函数&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 def is_authenticated(self):
      return True
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;认证函数&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;认证过程中使用我们自己编写的model，但是返回时依旧返回User&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;编写AuthBackend类，需要实现get_user和authenticate方法。&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
  class AuthBackend(object):
  def get_user(self,id):
      try:
          user=User.objects.get(pk=id)
      except:
          user=None
      return user

  def authenticate(self,username,password):
      try:
          user=Account1.objects.get(username=username)
          if password==user.shanyunji:
              return User.objects.get(username=username)
          else:
              return None
      except:
          return None
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;配置&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;编写好的AuthBackend类需要加入到settings中，在AUTHENTICATION_BACKENDS中加入自己编写好的类。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;AUTHENTICATION_BACKENDS中会依照顺序进行验证，如果第一个验证通过则通过，否则尝试下一个，只有所有认证都失败才失败。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;另一种方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;我们只需要更改Django默认登录验证中的authenticate函数即可，具体方法如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
  from django.contrib import auth

  def login_view(request):
  username = request.POST.get(&#39;username&#39;, &#39;&#39;)
  password = request.POST.get(&#39;password&#39;, &#39;&#39;)
  user = auth.authenticate(username=username, password=password)
  if user is not None and user.is_active:
      auth.login(request, user)
      return HttpResponseRedirect(&quot;/account/loggedin/&quot;)
  else:
      return HttpResponseRedirect(&quot;/account/invalid/&quot;)
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;登出方法更为简单：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
          auth.logout(request)
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 27 Apr 2015 06:03:21 +0800</pubDate>
        <link>/2015/04/27/Django-Auth/</link>
        <guid isPermaLink="true">/2015/04/27/Django-Auth/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django login/lgout 登录和登出</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#loginlgout&quot; id=&quot;markdown-toc-loginlgout&quot;&gt;login/lgout方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;登录模版&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;重定向&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#csrf&quot; id=&quot;markdown-toc-csrf&quot;&gt;CSRF&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;需要做用户登录，于是研究了下Django的登录和登出逻辑，发现还是挺简单实用的。具体的登录和登出实现如下：&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;loginlgout&quot;&gt;login/lgout方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Django已经为我们封装好了login和lgout函数，只需要我们在url.py中直接调用即可，具体使用方法如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
  from django.contrib.auth.views import login, logout

  urlpatterns = patterns(&#39;&#39;,
      (r&#39;^accounts/login/$&#39;, login),
      (r&#39;^accounts/logout/$&#39;, logout),
  )
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;按照常规，登录url为accounts/login/，登出为accounts/logout/&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;登录模版&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;login模版地址默认为template／registration／login.html&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;需要在login模版中编写登录表单，格式如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
  &amp;lt; form action=&quot;&quot; method=&quot;post&quot;&amp;gt;{ % csrf_token % }
  &amp;lt; label for=&quot;username&quot;&amp;gt;User name:
  &amp;lt; input type=&quot;text&quot; name=&quot;username&quot; value=&quot;&quot; id=&quot;username&quot;&amp;gt;
  &amp;lt; label for=&quot;password&quot;&amp;gt;Password:
  &amp;lt; input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&quot; id=&quot;password&quot;&amp;gt;
  &amp;lt; input type=&quot;submit&quot; value=&quot;login&quot; /&amp;gt;
  &amp;lt; /form&amp;gt;
  &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;重定向&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;登录验证成功后，默认会自动重定向到accounts／profile，需要编写该url对应的view函数&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;csrf&quot;&gt;CSRF&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;模版表单中通常加入｛％ csrf_token ％｝确保安全，同时在settings中间键中添加csrf中间键&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 24 Apr 2015 04:41:29 +0800</pubDate>
        <link>/2015/04/24/Django-login-and-lgout/</link>
        <guid isPermaLink="true">/2015/04/24/Django-login-and-lgout/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django 扩展manage.py命令</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#management&quot; id=&quot;markdown-toc-management&quot;&gt;management&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#basecommand&quot; id=&quot;markdown-toc-basecommand&quot;&gt;Basecommand类&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;运行&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;由于项目中添加了诸如文档、系统管理员这样的角色，因此需要执行命令来手动创建这些高权限账号，这就需要我们手动扩展manage.py命令，大致流程如下：&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;management&quot;&gt;management&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;所有需要扩展的manage命令都放在management的commands文件夹下，因此需要在应用中建立management文件夹，之后在该文件夹下建立commands文件夹&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;management和commands下都需要建立空的__init__.py文件&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;应用必须存在于INSTALLED_APPS中&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;commands下以  命令名.py  建立python文件，一个命令对应一个文件&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;basecommand&quot;&gt;Basecommand类&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;命令名.py 文件中编写格式如下：&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
  from django.core.management.base import BaseCommand
  class Command(BaseCommand):
      def handle(self, *args, **options):
          print args
          print options
  &lt;/code&gt;&lt;/pre&gt;

    &lt;ul&gt;
      &lt;li&gt;注意类名为Command、继承BaseCommand、方法名为handle&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;运行&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;进入 manage.py 目录下，运行 python manage.py hello a b c name＝shanyj&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 21 Apr 2015 03:56:09 +0800</pubDate>
        <link>/2015/04/21/Django-manage/</link>
        <guid isPermaLink="true">/2015/04/21/Django-manage/</guid>
        
        
        <category>Django</category>
        
      </item>
    
  </channel>
</rss>
