<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ShanYJ</title>
    <description>╭(╯^╰)╮吉吉的博客</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 04 Dec 2015 05:56:14 +0800</pubDate>
    <lastBuildDate>Fri, 04 Dec 2015 05:56:14 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Python APScheduler定时任务框架</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#apscheduler&quot; id=&quot;markdown-toc-apscheduler&quot;&gt;APScheduler&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;组件&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;原则&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;常用方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;三种调度&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-5&quot; id=&quot;markdown-toc-section-5&quot;&gt;时间格式&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-6&quot; id=&quot;markdown-toc-section-6&quot;&gt;案例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;apscheduler&quot;&gt;APScheduler&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;APScheduler&lt;/strong&gt;一个Python定时任务框架,可以用来实现date、interval和cron操作。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;安装&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;pip install apscheduler&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;组件&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;触发器(trigger)&lt;/strong&gt;:包含调度逻辑，每一个作业有它自己的触发器，用于决定接下来哪一个作业会运行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作业存储(job store)&lt;/strong&gt;:存储被调度的作业，默认的作业存储是简单地把作业保存在内存中，其他的作业存储是将作业保存在数据库中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;执行器(executor)&lt;/strong&gt;:处理作业的运行，他们通常通过在作业中提交制定的可调用对象到一个线程或者进城池来进行。当作业完成时，执行器将会通知调度器。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;调度器(scheduler)&lt;/strong&gt;:是其他的组成部分。你通常在应用只有一个调度器，应用的开发者通常不会直接处理作业存储、调度器和触发器，相反，调度器提供了处理这些的合适的接口。配置作业存储和执行器可以在调度器中完成，例如添加、修改和移除作业。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;原则&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;调度器选择&lt;/strong&gt;:这取决于你的应用环境和你使用APScheduler的目的。通常最常用的两个：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;–BlockingScheduler: 当调度器是你应用中唯一要运行的东西时使用。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;–BackgroundScheduler: 当你不运行任何其他框架时使用，并希望调度器在你应用的后台执行。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;作业存储选择&lt;/strong&gt;:你需要决定是否需要作业持久化。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;如果你总是在应用开始时重建job，你可以直接使用默认的作业存储（MemoryJobStore).&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果你需要将你的作业持久化，以避免应用崩溃和调度器重启时，你可以根据你的应用环境来选择具体的作业存储。例如：使用Mongo或者SQLAlchemyJobStore （用于支持大多数RDBMS）&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;执行器选择&lt;/strong&gt;:通常有两种:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;默认为ThreadPoolExecutor 通常用于大多数用途。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果你的工作负载中有较大的CPU密集型操作，你可以考虑用ProcessPoolExecutor来使用更多的CPU核。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;你也可以在同一时间使用两者，将进程池调度器作为第二执行器。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;常用方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;添加作业&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;使用add_job():
scheduler.add_job(myfunc, ‘interval’, minutes=2)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用装饰器：@sched.scheduled_job(‘cron’, id=’my_job_id’, day=’last sun’)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;add_job的第二个参数是trigger，它管理着作业的调度方式。它可以为date, interval或者cron。对于不同的trigger，对应的参数也相同。&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;移除作业&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;scheduler.remove_job(‘my_job_id’)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;暂停和继续作业&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;apscheduler.schedulers.base.BaseScheduler.pause_job()
apscheduler.schedulers.base.BaseScheduler.resume_job()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;获得job列表&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;scheduler.get_jobs()&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;关闭调度器&lt;/strong&gt;：&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;scheduler.shutdown(wait=False)
默认情况下调度器会等待所有正在运行的作业完成后，关闭所有的调度器和作业存储。如果你不想等待，可以将wait选项设置为False。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-4&quot;&gt;三种调度&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;cron  定时调度&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;year: 4位数字&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;month: 月 (1-12)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;day: 天 (1-31)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;week: 标准周 (1-53)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;day_of_week: 周中某天 (0-6 or mon,tue,wed,thu,fri,sat,sun)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;hour: 小时 (0-23)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;minute:分钟 (0-59)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;second: 秒 (0-59)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;start_date: 最早执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;end_date: 最晚执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;timezone: 执行时间区间&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;interval  间隔调度&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;weeks: 每隔几周执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;days: 每隔几天执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;hours: 每隔几小时执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;minutes: 每隔几分执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;seconds: 每隔几秒执行一次&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;start_date: 最早执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;end_date: 最晚执行时间&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;timezone: 执行时间区间&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;date  定时调度&lt;/strong&gt;:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;最基本的一种调度，作业只会执行一次。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;run_date: 在某天执行任务&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;timezone: 在某段时间执行任务&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-5&quot;&gt;时间格式&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Expression	Field	Description
*	         any	Fire on every value
*/a	         any	Fire everyavalues, starting from the minimum
a-b	         any	Fire on any value within thea-brange (a must be smaller than b)
a-b/c	     any	Fire everycvalues within thea-brange
xthy	     day	Fire on thex-th occurrence of weekdayywithin the month
lastx	     day	Fire on the last occurrence of weekdayxwithin the month
last	     day	Fire on the last day within the month
x,y,z	     any	Fire on any matching expression
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-6&quot;&gt;案例&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;可以先创建调度器，再配置和添加作业，这样你可以在不同的环境中得到更大的灵活性。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;下面是一个简单使用BlockingScheduler，并使用默认内存存储和默认执行器。
(默认选项分别是MemoryJobStore和ThreadPoolExecutor，其中线程池的最大线程数为10)。配置完成后使用start()方法来启动。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
def my_job():
    print &#39;shanyj&#39;
sched = BlockingScheduler()
sched.add_job(my_job, &#39;interval&#39;, seconds=5)
sched.start()
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;复杂的配置：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
from pymongo import MongoClient
from apscheduler.schedulers.blocking import BlockingScheduler
from apscheduler.jobstores.mongodb import MongoDBJobStore
from apscheduler.jobstores.memory import MemoryJobStore
from apscheduler.executors.pool import ThreadPoolExecutor, ProcessPoolExecutor
def my_job():
    print &#39;shanyj&#39;

host = &#39;127.0.0.1&#39;
port = 27017
client = MongoClient(host, port)

jobstores = {
&#39;mongo&#39;: MongoDBJobStore(collection=&#39;job&#39;, database=&#39;test&#39;, client=client),
&#39;default&#39;: MemoryJobStore()
}

executors = {
&#39;default&#39;: ThreadPoolExecutor(10),
&#39;processpool&#39;: ProcessPoolExecutor(3)
}

job_defaults = {
&#39;coalesce&#39;: False,
&#39;max_instances&#39;: 3
}

scheduler = BlockingScheduler(jobstores=jobstores, executors=executors, job_defaults=job_defaults)
scheduler.add_job(my_job, &#39;interval&#39;, seconds=5)
try:
    scheduler.start()
except SystemExit:
    scheduler.shutdown()
    client.close()
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 07 Jul 2015 04:14:54 +0800</pubDate>
        <link>/2015/07/07/APScheduler/</link>
        <guid isPermaLink="true">/2015/07/07/APScheduler/</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Django 多数据库</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#django&quot; id=&quot;markdown-toc-django&quot;&gt;Django多数据库&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;配置数据库&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#class&quot; id=&quot;markdown-toc-class&quot;&gt;配置class&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#classsettings&quot; id=&quot;markdown-toc-classsettings&quot;&gt;将数据库class添加至settings&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;同步数据库&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#modelclass-meta&quot; id=&quot;markdown-toc-modelclass-meta&quot;&gt;model的class meta&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#sql&quot; id=&quot;markdown-toc-sql&quot;&gt;使用底层sql&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;django&quot;&gt;Django多数据库&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;配置数据库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;在settings中进行配置。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
DATABASES = {
    #之所以这里仍然保留default数据库，是因为如果要使用Django的Auth应用或者Admin应用
    #我希望它默认将数据存放在default.db中，而不与其他数据搞混
     &#39;default&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: &#39;db/default.db&#39;,
        &#39;USER&#39;: &#39;&#39;,
        &#39;PASSWORD&#39;: &#39;&#39;,
        &#39;HOST&#39;: &#39;&#39;,
        &#39;PORT&#39;: &#39;&#39;,
    },

    #提供给userApp使用
     &#39;userdb&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: &#39;db/user.db&#39;,
        &#39;USER&#39;: &#39;&#39;,
        &#39;PASSWORD&#39;: &#39;&#39;,
        &#39;HOST&#39;: &#39;&#39;,
        &#39;PORT&#39;: &#39;&#39;,
    },

     &#39;essaydb&#39;: {
        &#39;ENGINE&#39;: &#39;django.db.backends.sqlite3&#39;,
        &#39;NAME&#39;: &#39;db/essay.db&#39;,
        &#39;USER&#39;: &#39;&#39;,
        &#39;PASSWORD&#39;: &#39;&#39;,
        &#39;HOST&#39;: &#39;&#39;,
        &#39;PORT&#39;: &#39;&#39;,
    },
}
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;class&quot;&gt;配置class&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;新建dbsettings.py , 编写下面 , class一般只改最后一个方法&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
class appdb(object):
    def db_for_read(self, model, **hints):
        #该方法定义读取时从哪一个数据库读取
        return self.__app_router(model)

    def db_for_write(self, model, **hints):
        #该方法定义写入时从哪一个数据库读取，如果读写分离，可再额外配置
        return self.__app_router(model)

    def allow_relation(self, obj1, obj2, **hints):
        #该方法用于判断传入的obj1和obj2是否允许关联，可用于多对多以及外键
        #同一个应用同一个数据库
        if obj1._meta.app_label == obj2._meta.app_label:
            return True
        #User和Essay是允许关联的
        elif obj1._meta.app_label in (&#39;userApp&#39;,&#39;essayApp&#39;) and obj2._meta.app_label in (&#39;userApp&#39;,&#39;essayApp&#39;):
            return True

    def allow_syncdb(self, db, model):
        #该方法定义数据库是否能和名为db的数据库同步
        return self.__app_router(model) == db

   #添加一个私有方法用来判断模型属于哪个应用，并返回应该使用的数据库
    def __app_router(self, model):
        if model._meta.app_label == &#39;userApp&#39;:
            return &#39;userdb&#39;
        elif model._meta.app_label == &#39;essayApp&#39;:
            return &#39;essaydb&#39;
        else :
            return &#39;default&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;classsettings&quot;&gt;将数据库class添加至settings&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;DATABASE_ROUTERS = [‘dbsettings.appdb’]&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;同步数据库&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;使用下列方法分别同步不同数据库：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
python manage.py syncdb #默认同步的数据库为&#39;default&#39;
python manage.py syncdb --database=userdb  #为userdb同步数据
python manage.py syncdb --database=essaydb #为essaydb同步数据
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;反向同步数据库&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
python manage.py inspectdb --database=userdb &amp;gt; shanyjuser/models.py
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;注意database＝后面是settings里的名字&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;modelclass-meta&quot;&gt;model的class meta&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;每个model的class meta
中 app_label = ‘myapp’
应和（2）中的最后一个方法相匹配！&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;sql&quot;&gt;使用底层sql&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;除了自带的model之外还可以使用底层sql&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;针对单数据库
        &lt;pre&gt;&lt;code&gt;
from django.db import connection, transaction
    cursor = connection.cursor()
    # 数据修改操作——提交要求
    cursor.execute(&quot;UPDATE bar SET foo = 1 WHERE baz = %s&quot;, [self.baz])
    transaction.commit_unless_managed()
    # 或者 transaction.set_dirty()
    # 数据检索操作,不需要提交
    cursor.execute(&quot;SELECT foo FROM bar WHERE baz = %s&quot;, [self.baz])
    row = cursor.fetchone()
    return row
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;针对多数据库
        &lt;pre&gt;&lt;code&gt;
from django.db import connections
cursor = connections[&#39;my_db_alias&#39;].cursor()
cursor.execute(&quot;UPDATE bar SET foo = 1 WHERE baz = %s&quot;, [self.baz])
transaction.commit_unless_managed(using=&#39;my_db_alias&#39;)
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Fri, 19 Jun 2015 05:30:27 +0800</pubDate>
        <link>/2015/06/19/Django-Databases/</link>
        <guid isPermaLink="true">/2015/06/19/Django-Databases/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>使用Github＋jekyll搭建Blog</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#jekyll&quot; id=&quot;markdown-toc-jekyll&quot;&gt;jekyll&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#ruby&quot; id=&quot;markdown-toc-ruby&quot;&gt;安装ruby&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#gem&quot; id=&quot;markdown-toc-gem&quot;&gt;安装gem&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#jekyll-1&quot; id=&quot;markdown-toc-jekyll-1&quot;&gt;安装jekyll&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#markdown&quot; id=&quot;markdown-toc-markdown&quot;&gt;本地编写markdown&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;本地启动博客&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#git&quot; id=&quot;markdown-toc-git&quot;&gt;推送至Git&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#blog&quot; id=&quot;markdown-toc-blog&quot;&gt;访问Blog&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;遇到的问题&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;jekyll&quot;&gt;jekyll&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;jekyll&lt;/strong&gt; ：将纯文本转化为静态网站和博客。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;ruby&quot;&gt;安装ruby&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通过 apt-get 安装ruby&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
sudo apt-get update
sudo apt-get install ruby
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;查看ruby版本&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
ruby -v
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;gem&quot;&gt;安装gem&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;通过 apt-get 安装gem&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
sudo apt-get install ruby-gems
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;更改gem源&lt;/strong&gt; : 在安装gem的过程中会出现找不到资源的error，我们需要从另外一个gem服务器下载安装。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
gem source -r https://rubygems.org/
gem source -a https://ruby.taobao.org
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;查看gem源&lt;/strong&gt; : 使用以下命令查看gem源是否更改成功。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
gem sources -l
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;jekyll-1&quot;&gt;安装jekyll&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;安装jekyll&lt;/strong&gt; :&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
gem install jekyll
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;安装rdiscount&lt;/strong&gt; : 这个是用来解析Markdown标记的解析包。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
gem install rdiscount
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;markdown&quot;&gt;本地编写markdown&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;一定要确保你的文章要保存为UTF-8 无 BOM 格式才行。 文件名称不能是中文。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当然也可以去Jekyll themes等网站下载已有模版进行改写。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section&quot;&gt;本地启动博客&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;编译md文件，启动博客：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;
jekyll serve
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;访问http://127.0.0.1:4000 , 即可查看blog效果。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;git&quot;&gt;推送至Git&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;在Git上创建新项目，具体步骤此处不再赘述。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;将本地工程推送至Git&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;mkdir新文件夹,将工程移入,执行下列语句。&lt;/p&gt;

        &lt;pre&gt;&lt;code&gt;
git init
git add .
git commit -m &quot;up&quot;
git remote add origin git@github.com:shanyj/shanyj.github.io.git
git push -u origin master
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;blog&quot;&gt;访问Blog&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;以此项目为例，直接访问shanyj.github.io即可。&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;遇到的问题&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;从jekyll themes上clone的代码，大部分需要在执行 jekyll serve 前执行 bundle install&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;bundle安装：
        &lt;pre&gt;&lt;code&gt;
gem install bundle
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;执行：
        &lt;pre&gt;&lt;code&gt;
bundle install
&lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 16 Jun 2015 03:17:45 +0800</pubDate>
        <link>/2015/06/16/Set-up-Blog/</link>
        <guid isPermaLink="true">/2015/06/16/Set-up-Blog/</guid>
        
        
        <category>前端杂谈</category>
        
      </item>
    
  </channel>
</rss>
