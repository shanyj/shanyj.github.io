<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>ShanYJ</title>
    <description>╭(╯^╰)╮吉吉的博客</description>
    <link>/</link>
    <atom:link href="/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Fri, 08 Jan 2016 17:01:00 +0800</pubDate>
    <lastBuildDate>Fri, 08 Jan 2016 17:01:00 +0800</lastBuildDate>
    <generator>Jekyll v3.0.1</generator>
    
      <item>
        <title>Mysql 库&amp;表&amp;属性命令</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;库&amp;amp;表&amp;amp;属性命令&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;这里主要记录下Mysql中的Mysql库&amp;amp;表&amp;amp;属性命令的一些用法&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;库&amp;amp;表&amp;amp;属性命令&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SELECT INTO&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT INTO 语句从一个表中选取数据，然后把数据插入另一个表中&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT column_name(s) INTO new_table_name [IN externaldatabase] FROM old_tablename&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;IN 子句可用于向另一个数据库中拷贝表&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT * INTO Persons IN ‘Backup.mdb’ FROM Persons&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CREATE DATABASE&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;CREATE DATABASE 用于创建数据库&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;CREATE DATABASE database_name&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CREATE TABLE&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;CREATE DATABASE 用于创建数据库
        &lt;pre&gt;&lt;code&gt;
 CREATE TABLE 表名称
 (
 列名称1 数据类型,
 列名称2 数据类型,
 列名称3 数据类型,
 ....
 )
 &lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;NOT NULL&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;NOT NULL 约束强制列不接受 NULL 值
        &lt;pre&gt;&lt;code&gt;
 CREATE TABLE Persons
 (
 Id_P int NOT NULL,
 LastName varchar(255) NOT NULL,
 FirstName varchar(255),
 Address varchar(255),
 City varchar(255)
 )
 &lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;UNIQUE&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;UNIQUE 约束唯一标识数据库表中的每条记录
        &lt;pre&gt;&lt;code&gt;
 CREATE TABLE Persons
 (
 Id_P int NOT NULL,
 City varchar(255),
 UNIQUE (Id_P)
 )
 &lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;如果需要命名 UNIQUE 约束，以及为多个列定义 UNIQUE 约束
        &lt;pre&gt;&lt;code&gt;
 CREATE TABLE Persons
 (
 Id_P int NOT NULL,
 City varchar(255),
 CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)
 )
 &lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;当表已被创建时，如需在 “Id_P” 列创建 UNIQUE 约束，请使用下列 SQL：&lt;/p&gt;

        &lt;p&gt;ALTER TABLE Persons ADD UNIQUE (Id_P)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如需命名 UNIQUE 约束，并定义多个列的 UNIQUE 约束，请使用下面的 SQL 语法：&lt;/p&gt;

        &lt;p&gt;ALTER TABLE Persons ADD CONSTRAINT uc_PersonID UNIQUE (Id_P,LastName)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如需撤销 UNIQUE 约束，请使用下面的 SQL:&lt;/p&gt;

        &lt;p&gt;ALTER TABLE Persons DROP INDEX uc_PersonID&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;PRIMARY KEY&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;PRIMARY KEY 约束唯一标识数据库表中的每条记录
        &lt;pre&gt;&lt;code&gt;
 CREATE TABLE Persons
 (
 Id_P int NOT NULL,
 City varchar(255),
 PRIMARY KEY (Id_P)
 )
 &lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FOREIGN KEY&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;一个表中的 FOREIGN KEY 指向另一个表中的 PRIMARY KEY
        &lt;pre&gt;&lt;code&gt;
 CREATE TABLE Orders
 (
 Id_O int NOT NULL,
 Id_P int,
 PRIMARY KEY (Id_O),
 FOREIGN KEY (Id_P) REFERENCES Persons(Id_P)
 )
 &lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CHECK&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;CHECK 约束用于限制列中的值的范围
        &lt;pre&gt;&lt;code&gt;
CREATE TABLE Persons
 (
 Id_P int NOT NULL,
 City varchar(255),
 CHECK (Id_P&amp;gt;0)
 )
 &lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DEFAULT&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;创建 DEFAULT 约束
        &lt;pre&gt;&lt;code&gt;
CREATE TABLE Persons
 (
 Id_P int NOT NULL,
 City varchar(255) DEFAULT &#39;Sandnes&#39;
 )
 &lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果在表已存在的情况下为 “City” 列创建 DEFAULT 约束，请使用下面的 SQL&lt;/p&gt;

        &lt;p&gt;ALTER TABLE Persons
 ALTER City SET DEFAULT ‘SANDNES’&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如需撤销 DEFAULT 约束，请使用下面的 SQL&lt;/p&gt;

        &lt;p&gt;ALTER TABLE Persons
 ALTER City DROP DEFAULT&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;CREATE INDEX&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;在表上创建一个简单的索引&lt;/p&gt;

        &lt;p&gt;CREATE INDEX index_name
 ON table_name (column_name)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在表上创建一个唯一的索引。唯一的索引意味着两个行不能拥有相同的索引值。&lt;/p&gt;

        &lt;p&gt;CREATE UNIQUE INDEX index_name
 ON table_name (column_name)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;假如您希望索引不止一个列，您可以在括号中列出这些列的名称，用逗号隔开：&lt;/p&gt;

        &lt;p&gt;CREATE INDEX PersonIndex
 ON Person (LastName, FirstName)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;删除&lt;/p&gt;

        &lt;p&gt;ALTER TABLE table_name DROP INDEX index_name&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DROP&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;DROP TABLE 语句用于删除表（表的结构、属性以及索引也会被删除）：&lt;/p&gt;

        &lt;p&gt;DROP TABLE 表名称&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;DROP DATABASE 语句用于删除数据库:&lt;/p&gt;

        &lt;p&gt;DROP DATABASE 数据库名称&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SQL TRUNCATE TABLE 语句&lt;/p&gt;

        &lt;p&gt;如果我们仅仅需要除去表内的数据&lt;/p&gt;

        &lt;p&gt;TRUNCATE TABLE 表名称&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ALTER&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;如需在表中添加列，请使用下列语法&lt;/p&gt;

        &lt;p&gt;ALTER TABLE table_name
 ADD column_name datatype&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;要删除表中的列，请使用下列语法&lt;/p&gt;

        &lt;p&gt;ALTER TABLE table_name
 DROP COLUMN column_name&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;要改变表中列的数据类型，请使用下列语法&lt;/p&gt;

        &lt;p&gt;ALTER TABLE table_name
 ALTER COLUMN column_name datatype&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AUTO INCREMENT&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;通常希望在每次插入新记录时，自动地创建主键字段的值
        &lt;pre&gt;&lt;code&gt;
CREATE TABLE Persons
 (
 P_Id int NOT NULL AUTO_INCREMENT,
 LastName varchar(255) NOT NULL,
 FirstName varchar(255),
 Address varchar(255),
 City varchar(255),
 PRIMARY KEY (P_Id)
 )
 &lt;/code&gt;&lt;/pre&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;默认地，AUTO_INCREMENT 的开始值是 1，每条新记录递增 1&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;要让 AUTO_INCREMENT 序列以其他的值起始，请使用下列 SQL 语法：&lt;/p&gt;

        &lt;p&gt;ALTER TABLE Persons AUTO_INCREMENT=100&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;VIEW&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;视图是基于 SQL 语句的结果集的可视化的表&lt;/p&gt;

        &lt;p&gt;CREATE VIEW view_name AS
 SELECT column_name(s)
 FROM table_name
 WHERE condition&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用下面的语法来更新视图&lt;/p&gt;

        &lt;p&gt;CREATE OR REPLACE VIEW view_name AS
 SELECT column_name(s)
 FROM table_name
 WHERE condition&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;删除&lt;/p&gt;

        &lt;p&gt;DROP VIEW view_name&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 07 Nov 2015 03:52:26 +0800</pubDate>
        <link>/2015/11/07/Mysql-orders/</link>
        <guid isPermaLink="true">/2015/11/07/Mysql-orders/</guid>
        
        
        <category>Mysql</category>
        
      </item>
    
      <item>
        <title>Mysql Join</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#join&quot; id=&quot;markdown-toc-join&quot;&gt;join语句&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;这里主要记录下Mysql中的Join语句的一些用法&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;join&quot;&gt;join语句&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;JOIN&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;我们需要从两个或更多的表中获取结果。我们就需要执行 join&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT Persons.LastName, Persons.FirstName, Orders.OrderNo
 FROM Persons
 JOIN Orders
 ON Persons.Id_P = Orders.Id_P
 ORDER BY Persons.LastName&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;INNER JOIN&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;INNER JOIN 与 JOIN 是相同的&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LEFT JOIN&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;LEFT JOIN 关键字会从左表 (table_name1) 那里返回所有的行，即使在右表 (table_name2) 中没有匹配的行&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT column_name(s)
 FROM table_name1
 LEFT JOIN table_name2
 ON table_name1.column_name=table_name2.column_name&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;只要左边表有column_name就取出，如右边表有一样的column_name则合并，没有则留空&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;RIGHT JOIN&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;RIGHT JOIN 关键字会从右表 (table_name2) 那里返回所有的行，即使在左表 (table_name1) 中没有匹配的行&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT column_name(s)
 FROM table_name1
 RIGHT JOIN table_name2
 ON table_name1.column_name=table_name2.column_name&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;FULL JOIN&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;FULL JOIN关键字会从左右表那里返回所有的行&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT column_name(s)
 FROM table_name1
 FULL JOIN table_name2
 ON table_name1.column_name=table_name2.column_name&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;UNION&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT column_name(s) FROM table_name1
 UNION
 SELECT column_name(s) FROM table_name2&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使增加了结果的行数，并没有增加列数，所以列数必须相同&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Tue, 03 Nov 2015 04:13:46 +0800</pubDate>
        <link>/2015/11/03/Mysql-join/</link>
        <guid isPermaLink="true">/2015/11/03/Mysql-join/</guid>
        
        
        <category>Mysql</category>
        
      </item>
    
      <item>
        <title>Mysql 基础语句&amp;限制语句</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;基础语句&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;基础语句&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;这里主要记录下Mysql中的基础操作语句和一些限制语句&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;基础语句&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;SELECT&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT 列名称 FROM 表名称&lt;/p&gt;

        &lt;p&gt;SELECT LastName,FirstName FROM Persons&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT 列名称 FROM 表名称 WHERE 列 运算符 值&lt;/p&gt;

        &lt;p&gt;SQL使用单引号来环绕文本值,如果是数值，不使用引号。&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;文本值：&lt;/p&gt;

        &lt;p&gt;这是正确的：&lt;/p&gt;

        &lt;p&gt;SELECT * FROM Persons WHERE FirstName=’Bush’&lt;/p&gt;

        &lt;p&gt;这是错误的：&lt;/p&gt;

        &lt;p&gt;SELECT * FROM Persons WHERE FirstName=Bush&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;数值：&lt;/p&gt;

        &lt;p&gt;这是正确的：&lt;/p&gt;

        &lt;p&gt;SELECT * FROM Persons WHERE Year&amp;gt;1965&lt;/p&gt;

        &lt;p&gt;这是错误的：&lt;/p&gt;

        &lt;p&gt;SELECT * FROM Persons WHERE Year&amp;gt;’1965’&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来&lt;/p&gt;

        &lt;p&gt;SELECT * FROM Persons WHERE (FirstName=’Thomas’ OR FirstName=’William’)
 AND LastName=’Carter&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;INSERT INTO&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;INSERT INTO 表名称 VALUES (值1, 值2,….)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;INSERT INTO table_name (列1, 列2,…) VALUES (值1, 值2,….) AND LastName=’Carter&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;UPDATE 表名称 SET 列名称 = 新值 WHERE 列名称 = 某值&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;更新某一行中的若干列&lt;/p&gt;

        &lt;p&gt;UPDATE Person SET Address = ‘Zhongshan 23’, City = ‘Nanjing’
 WHERE LastName = ‘Wilson’&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DELETE&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;DELETE FROM 表名称 WHERE 列名称 = 值&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;删除整个表数据&lt;/p&gt;

        &lt;p&gt;DELETE * FROM table_name&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;DISTINCT&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;关键词 DISTINCT 用于返回唯一不同的值&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT DISTINCT 列名称 FROM 表名称&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;ORDER BY&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;ORDER BY 语句用于根据指定的列对结果集进行排序&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;以逆字母顺序显示公司名称，并以数字顺序显示顺序号：&lt;/p&gt;

        &lt;p&gt;SELECT Company, OrderNumber FROM Orders ORDER BY Company DESC, OrderNumber ASC&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;基础语句&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LIMIT&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;SELECT column_name(s) FROM table_name LIMIT number setp&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;LIKE&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT column_name(s) FROM table_name WHERE column_name LIKE pattern&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;pattern格式：    %	： 替代一个或多个字符，
 _ ： 仅替代一个字符，
 [charlist] ： 字符列中的任何单一字符，
 [^charlist]或[!charlist] ： 不在字符列中的任何单一字符&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;IN&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;SELECT column_name(s) FROM table_name WHERE column_name IN (value1,value2,…)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;BETWEEN&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如需使用上面的例子显示范围之外的人，请使用 NOT 操作符：&lt;/p&gt;

        &lt;p&gt;SELECT * FROM Persons WHERE LastName NOT BETWEEN ‘Adams’ AND ‘Carter’&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;AS&lt;/strong&gt;&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;为列名称和表名称指定别名&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;列的 SQL Alias 语法&lt;/p&gt;

        &lt;p&gt;SELECT column_name AS alias_name FROM table_name&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用表名称别名&lt;/p&gt;

        &lt;p&gt;SELECT po.OrderID, p.LastName FROM Persons AS p, Product_Orders AS po WHERE p.LastName=’Adams’ AND p.FirstName=’John’&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 Nov 2015 05:23:41 +0800</pubDate>
        <link>/2015/11/02/Mysql-base/</link>
        <guid isPermaLink="true">/2015/11/02/Mysql-base/</guid>
        
        
        <category>Mysql</category>
        
      </item>
    
      <item>
        <title>Django captcha 验证码</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;建立表单&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;验证表单&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;模板显示&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;登录功能中验证码是十分重要的，在这里就简单的介绍Django中验证码的实现&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;安装&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;pip install  django-simple-captcha&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;配置&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 INSTALLED_APPS中加入captcha

 urlpatterns += patterns(&#39;&#39;,
 url(r&#39;^captcha/&#39;, include(&#39;captcha.urls&#39;)),
 )
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;建立表单&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;建立表单&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
from django.core.cache import cache
from django import forms
from captcha.fields import CaptchaField
class TestForm(forms.Form):
 name=forms.CharField()
 def clean_name(self):
     clean_name=self.cleaned_data[&#39;name&#39;]
     if clean_name==&#39;shanyj&#39;:
         return clean_name
     else:
         raise forms.ValidationError(&quot;aaaa!&quot;)
class CForm(forms.Form):
 captcha = CaptchaField()
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;验证表单&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;验证表单&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
def some_view(request):
 form2=&#39;&#39;
 if request.POST:
     if request.POST.get(&#39;captcha_0&#39;,&#39;na&#39;)!=&#39;na&#39;:
         form1=TestForm(request.POST)
         form2=CForm(request.POST)
         if form1.is_valid() and form2.is_valid():
             cache.delete(&#39;pass&#39;)
             return HttpResponse(&#39;ok&#39;)
         else:
             try:
                 cache.incr(&#39;pass&#39;)
             except:
                 cache.set(&#39;pass&#39;,1,3600)
     else:
         form1=TestForm(request.POST)
         if form1.is_valid():
             cache.delete(&#39;pass&#39;)
             return HttpResponse(&#39;ok&#39;)
         else:
             try:
                 cache.incr(&#39;pass&#39;)
             except:
                 cache.set(&#39;pass&#39;,1,3600)
 else:
     form1=TestForm()
 if cache.get(&#39;pass&#39;)&amp;gt;3:
     form2=CForm()
 return render_to_response(&#39;template.html&#39;,RequestContext(request,{&#39;form1&#39;:form1,&#39;form&#39;:form2}))
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-4&quot;&gt;模板显示&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;模板显示&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 { % load staticfiles % }

 &amp;lt; form action=&#39;.&#39; method=&#39;POST&#39; &amp;gt;{ % csrf_token % }
     { { form1 } }
     { % if form.captcha % }
     { { form.captcha } }
     { % endif % }
     &amp;lt; input type=&quot;submit&quot; /&amp;gt;
     &amp;lt; button class=&#39;captcha-refresh&#39;&amp;gt;刷新&amp;lt; /button&amp;gt;
     { % if form.captcha.errors % }
     &lt;p&gt;{ { form.captcha.errors } }&lt;/p&gt;
     { % endif % }
 

 &amp;lt; script type=&quot;text/javascript&quot; src=&#39;{ % static &quot;js/jquery.js&quot; % }&#39;&amp;gt;
 &amp;lt; script type=&quot;text/javascript&quot;&amp;gt;
 $(&#39;.captcha-refresh&#39;).click(function(){
     form = $(this).parents(&#39;form&#39;);
     $.getJSON(&#39;/captcha/refresh/&#39;, {}, function(json) {
         $(&#39;.captcha&#39;).attr(&#39;url&#39;,json.image_url);
         $(&#39;.captcha&#39;).attr(&#39;src&#39;,json.image_url);
         $(&#39;#id_captcha_0&#39;).attr(&#39;value&#39;,json.image_url.split(&#39;/&#39;)[3]);
     });
     return false;
 });
 &amp;lt; /script&amp;gt;
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 28 Oct 2015 04:23:34 +0800</pubDate>
        <link>/2015/10/28/Django-captcha/</link>
        <guid isPermaLink="true">/2015/10/28/Django-captcha/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Django 静态文件</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;安装和调用&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#mediastatic&quot; id=&quot;markdown-toc-mediastatic&quot;&gt;media&amp;amp;static&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;使用&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;静态文件指像css,js,images之类的文件,在Django里面静态文件的处理十分简单，这里就mark一下&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;安装和调用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;installapp中加入 django.contrib.staticfiles&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;TEMPLATE_CONTEXT_PROCESSORS中加入’django.core.context_processors.media’&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;mediastatic&quot;&gt;media&amp;amp;static&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;静态文件的处理又包括STATIC和MEDIA两类&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;MEDIA:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;指用户上传的文件，比如在Model里面的FileFIeld，ImageField上传的文件&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;如果定义MEDIA_ROOT=c:\temp\media，那么File=models.FileField(upload_to=”abc/”)，上传的文件就会被保存到c:\temp\media\abc&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;MEDIA_ROOT必须是本地路径的绝对路径,MEDIA_ROOT=os.path.join(PROJECT_PATH,’media/’).replace(‘\’,’/’)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;MEDIA_URL是指从浏览器访问时的地址前缀，MEDIA_URL=”/media/”&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;STATIC:&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;主要指的是如css,js,images这样文件&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;STATIC_ROOT与MEDIA_ROOT位置不能一样&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;在每个app所在文夹均可以建立一个static文件夹，
         然后当运行collectstatic时，Django会遍历INSTALL_APPS里面所有app的static文件夹，
         将里面所有的文件复制到STATIC_ROOT&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;一般在和templates相同的位置上建立static和media目录&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;使用&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;settings配置&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
    MEDIA_URL=&quot;/media/&quot;
    STATIC_URL=&quot;/static/&quot;
    STATICFILES_DIRS = (
        os.path.join(os.path.dirname(__file__), &quot;static&quot;),
    )

 &lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;view调用：render_to_response(‘hello.html’,RequestContext(request))&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模板调用&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
     { % load staticfiles % }
    &amp;lt; img src=&quot;{ % static &#39;images/hi.jpg&#39; % }&quot; / &amp;gt;
 &lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 23 Oct 2015 03:43:42 +0800</pubDate>
        <link>/2015/10/23/Python-static/</link>
        <guid isPermaLink="true">/2015/10/23/Python-static/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Python 进程间通信</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#queue&quot; id=&quot;markdown-toc-queue&quot;&gt;Queue&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pipe&quot; id=&quot;markdown-toc-pipe&quot;&gt;Pipe&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#pool&quot; id=&quot;markdown-toc-pool&quot;&gt;Pool&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;这里主要讲解下python中进程间通信的一些手段&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;queue&quot;&gt;Queue&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;put方法用以插入数据到队列中，put方法还有两个可选参数：blocked和timeout。
如果blocked为True（默认值），并且timeout为正值，该方法会阻塞timeout指定的时间，直到该队列有剩余的空间。
如果超时，会抛出Queue.Full异常。如果blocked为False，但该Queue已满，会立即抛出Queue.Full异常&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;get方法可以从队列读取并且删除一个元素。同样，get方法有两个可选参数：blocked和timeout。
如果blocked为True（默认值），并且timeout为正值，那么在等待时间内没有取到任何元素，会抛出Queue.Empty异常。
如果blocked为False，有两种情况存在，如果Queue有一个值可用，则立即返回该值，否则，如果队列为空，则立即抛出Queue.Empty异常&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;例子&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
import multiprocessing
def writer_proc(q):
    try:
        q.put(1, block = False)
    except:
        pass
def reader_proc(q):
    try:
        print q.get(block = False)
    except:
        pass
if __name__ == &quot;__main__&quot;:
    q = multiprocessing.Queue()
    writer = multiprocessing.Process(target=writer_proc, args=(q,))
    writer.start()
    reader = multiprocessing.Process(target=reader_proc, args=(q,))
    reader.start()
    reader.join()
    writer.join()
 &lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pipe&quot;&gt;Pipe&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Pipe方法返回(conn1, conn2)代表一个管道的两个端&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Pipe方法有duplex参数，如果duplex参数为True(默认值)，那么这个管道是全双工模式，也就是说conn1和conn2均可收发。
duplex为False，conn1只负责接受消息，conn2只负责发送消息&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;send和recv方法分别是发送和接受消息的方法。
例如，在全双工模式下，可以调用conn1.send发送消息，conn1.recv接收消息。
如果没有消息可接收，recv方法会一直阻塞。如果管道已经被关闭，那么recv方法会抛出EOFError&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;例子&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
def proc1(pipe):
    while True:
        for i in xrange(10000):
            print &quot;send: %s&quot; %(i)
            pipe.send(i)
            time.sleep(1)

def proc2(pipe):
    while True:
        print &quot;proc2 rev:&quot;, pipe.recv()
        time.sleep(1)

if __name__ == &quot;__main__&quot;:
    pipe = multiprocessing.Pipe()
    p1 = multiprocessing.Process(target=proc1, args=(pipe[0],))
    p2 = multiprocessing.Process(target=proc2, args=(pipe[1],))
    p1.start()
    p2.start()
    p1.join()
    p2.join()
 &lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;pool&quot;&gt;Pool&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Pool可以提供指定数量的进程，供用户调用，当有新的请求提交到pool中时，如果池还没有满，
那么就会创建一个新的进程用来执行该请求；但如果池中的进程数已经达到规定最大值，那么该请求就会等待，直到池中有进程结束，才会创建新的进程来它&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;apply_async(func[, args[, kwds[, callback]]]) 它是非阻塞，apply(func[, args[, kwds]])是阻塞的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;close() : 关闭pool，使其不在接受新的任务。只接受apply_async(func, (msg, ))剩余的&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;terminate() : 结束工作进程，不在处理未完成的任务&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;join() : 主进程阻塞，等待子进程的退出， join方法要在close或terminate之后使用&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;非阻塞例子&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
import multiprocessing
import time
def func(msg):
    print &quot;msg:&quot;, msg
    time.sleep(3)
    print &quot;end&quot;

if __name__ == &quot;__main__&quot;:
    pool = multiprocessing.Pool(processes = 3)
    for i in xrange(4):
        msg = &quot;hello %d&quot; %(i)
        pool.apply_async(func, (msg, ))   #维持执行的进程总数为processes，当一个进程执行完毕后会添加新的进程进去

    pool.close()
    pool.join()   #调用join之前，先调用close函数，否则会出错。执行完close后不会有新的进程加入到pool,join函数等待所有子进程结束
    print &quot;Sub-process(es) done.&quot;
 &lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;阻塞例子&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
def func(msg):
    print &quot;msg:&quot;, msg
    time.sleep(3)
    print &quot;end&quot;

if __name__ == &quot;__main__&quot;:
    pool = multiprocessing.Pool(processes = 3)
    for i in xrange(4):
        msg = &quot;hello %d&quot; %(i)
        pool.apply(func, (msg, ))

    pool.close()
    pool.join()
    print &quot;Sub-process(es) done.&quot;

结果:
msg: hello 0
end
msg: hello 1
end
msg: hello 2
end
msg: hello 3
end
Sub-process(es) done.
 &lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 20 Oct 2015 06:03:33 +0800</pubDate>
        <link>/2015/10/20/Python-Procon/</link>
        <guid isPermaLink="true">/2015/10/20/Python-Procon/</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Python 进程及同步</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;进程模块&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#with&quot; id=&quot;markdown-toc-with&quot;&gt;with语句&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#lock&quot; id=&quot;markdown-toc-lock&quot;&gt;lock&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#semaphore&quot; id=&quot;markdown-toc-semaphore&quot;&gt;Semaphore&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#event&quot; id=&quot;markdown-toc-event&quot;&gt;Event&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;这里主要讲解下python中进程和进程同步的一些知识&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;进程模块&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;创建进程的类：Process([group [, target [, name [, args [, kwargs]]]]])，target表示调用对象，args表示调用对象的位置参数元组。
kwargs表示调用对象的字典。name为别名&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;方法：is_alive()、join([timeout])、run()、start()、terminate()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;属性：authkey、daemon（要通过start()设置）、exitcode(进程在运行时为None、如果为–N，表示被信号N结束）、name、pid&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;例子&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
import multiprocessing
import time
def worker(interval):
    n = 5
    while n &amp;gt; 0:
        print(&quot;The time is {0}&quot;.format(time.ctime()))
        time.sleep(interval)
        n -= 1
if __name__ == &quot;__main__&quot;:
    p = multiprocessing.Process(target = worker, args = (3,))
    p.start()
    print &quot;p.pid:&quot;, p.pid
    print &quot;p.name:&quot;, p.name
    print &quot;p.is_alive:&quot;, p.is_alive()

print(&quot;The number of CPU is:&quot; + str(multiprocessing.cpu_count()))
for p in multiprocessing.active_children():
    print(&quot;child   p.name:&quot; + p.name + &quot;\tp.id&quot; + str(p.pid))
print &quot;END!!!!!!!!!!!!!!!!!&quot;
 &lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;将进程定义为类&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
import multiprocessing
import time
class ClockProcess(multiprocessing.Process):
    def __init__(self, interval):
        multiprocessing.Process.__init__(self)
        self.interval = interval

    def run(self):
        n = 5
        while n &amp;gt; 0:
            print(&quot;the time is {0}&quot;.format(time.ctime()))
            time.sleep(self.interval)
            n -= 1
if __name__ == &#39;__main__&#39;:
    p = ClockProcess(3)
    p.start()
 &lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;当子进程设置了daemon=True属性，主进程结束，它们就随着结束了&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;with&quot;&gt;with语句&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;with 语句适用于对资源进行访问的场合，确保不管使用过程中是否发生异常都会执行必要的“清理”操作，
释放资源，比如文件使用后自动关闭、线程中锁的自动获取和释放等&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;with所求值的对象必须有一个__enter__()方法，一个__exit__()方法。
紧跟with后面的语句被求值后，返回对象的__enter__()方法被调用，这个方法的返回值将被赋值给as后面的变量。
当with后面的代码块全部被执行完之后，将调用前面返回对象的__exit__()方法&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;例子&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
class Sample:
    def __enter__(self):
        print &quot;In&quot;
        return &quot;Foo&quot;
    def __exit__(self, type,value, trace):
        print &quot;out&quot;
def get_sample():
    return Sample()
with get_sample() as sample:
    print &quot;sample:&quot;
    print sample

结果
In
sample:
Foo
out
 &lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;lock&quot;&gt;lock&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Lock对象的状态可以为locked和unlocked
使用acquire()设置为locked状态；
使用release()设置为unlocked状态&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;如果当前的状态为unlocked，则acquire()会将状态改为locked然后立即返回。
当状态为locked的时候，acquire()将被阻塞直到另一个线程中调用release()来将状态改为unlocked，然后acquire()才可以再次将状态置为locked&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;例子&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
import multiprocessing
import sys
def worker_with(lock, f):
    with lock:
        fs = open(f, &#39;a+&#39;)
        n = 10
        while n &amp;gt; 1:
            fs.write(&quot;Lockd acquired via with\n&quot;)
            n -= 1
        fs.close()

def worker_no_with(lock, f):
    lock.acquire()
    try:
        fs = open(f, &#39;a+&#39;)
        n = 10
        while n &amp;gt; 1:
            fs.write(&quot;Lock acquired directly\n&quot;)
            n -= 1
        fs.close()
    finally:
        lock.release()

if __name__ == &quot;__main__&quot;:
    lock = multiprocessing.Lock()
    f = &quot;file.txt&quot;
    w = multiprocessing.Process(target = worker_with, args=(lock, f))
    nw = multiprocessing.Process(target = worker_no_with, args=(lock, f))
    w.start()
    nw.start()
    print &quot;end&quot;
 &lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;Lock.acquire(blocking=True, timeout=-1),blocking参数表示是否阻塞当前线程等待，timeout表示阻塞时的等待时间 。
如果成功地获得lock，则acquire()函数返回True，否则返回False，timeout超时时如果还没有获得lock仍然返回False&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;semaphore&quot;&gt;Semaphore&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Semaphore管理一个内置的计数器，
每当调用acquire()时内置计数器-1；
调用release() 时内置计数器+1&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;计数器不能小于0；当计数器为0时，acquire()将阻塞线程直到其他线程调用release()&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;例子&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
def worker(s, i):
    s.acquire()
    print(multiprocessing.current_process().name + &quot;acquire&quot;);
    time.sleep(i)
    print(multiprocessing.current_process().name + &quot;release\n&quot;);
    s.release()

if __name__ == &quot;__main__&quot;:
    s = multiprocessing.Semaphore(2)
    for i in range(5):
        p = multiprocessing.Process(target = worker, args=(s, i*2))
        p.start()
 &lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;event&quot;&gt;Event&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Event内部包含了一个标志位，初始的时候为false。
可以使用使用set()来将其设置为true；
或者使用clear()将其从新设置为false&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以使用is_set()来检查标志位的状态&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;另一个最重要的函数就是wait(timeout=None)，用来阻塞当前线程，直到event的内部标志位被设置为true或者timeout超时&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;例子&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
def wait_for_event_timeout(e, t):
    print(&quot;wait_for_event_timeout:starting&quot;)
    e.wait(t)  //或e.wait()
    print(&quot;wait_for_event_timeout:e.is_set-&amp;gt;&quot; + str(e.is_set()))

if __name__ == &quot;__main__&quot;:
    e = multiprocessing.Event()
    w2 = multiprocessing.Process(name = &quot;non-block&quot;,
            target = wait_for_event_timeout,
            args = (e, 2))
    w2.start()
    time.sleep(3)
    e.set()
    print(&quot;main: event is set&quot;)
 &lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Mon, 19 Oct 2015 05:02:32 +0800</pubDate>
        <link>/2015/10/19/Python-Pro/</link>
        <guid isPermaLink="true">/2015/10/19/Python-Pro/</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Python 装饰器</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;使用方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;其他&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;装饰器可以对一个函数、方法或者类进行加工,个人理解为一个闭包，下面就来看一下装饰器的几种使用方法&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;使用方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;无参数装饰器&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;相当于foo=deco(foo)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;
 def deco(func):
     print(&quot;deco&quot;)
     return func

 @deco
 def foo():
     print(&quot;foo&quot;)
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;装饰器有参，函数无参&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;相当于foo = deco(argv)(foo)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;
 def deco(argv):
     def decorator(func):
         print(&quot;decorator&quot;)
         return func
     print(argv)
     return decorator

 @deco(&quot;123&quot;)
 def foo():
     print(&quot;foo&quot;)
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;装饰器、函数都有参&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;相当于foo = deco(argv)(foo)(data)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;使用&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;

    &lt;pre&gt;&lt;code&gt;
 from functools import wraps

 def deco(argv):
     def decorator(func):
         @wraps(func)
         def wrapper(*args, **kwargs):
             return func(*args, **kwargs)
         print(&quot;decorator&quot;)
         return wrapper
     print(argv)
     return decorator

 @deco(&quot;123&quot;)
 def foo(data):
     &quot;this is foo&quot;
     print(&quot;foo&quot;)
     print(data)
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;其他&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;注意多个装饰器的执行顺序，应该是先执行下面的，然后是上面的。这里应先执行deco1，然后是deco2&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;
    @deco2
    @deco1
 &lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 16 Oct 2015 03:43:42 +0800</pubDate>
        <link>/2015/10/16/Python-deco/</link>
        <guid isPermaLink="true">/2015/10/16/Python-deco/</guid>
        
        
        <category>Python</category>
        
      </item>
    
      <item>
        <title>Django 通用视图</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;重定向&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#model&quot; id=&quot;markdown-toc-model&quot;&gt;显示model&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;这次mark一下Django通用视图的一些基本用法和简单地配置&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;重定向&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;直接重定向&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 from django.views.generic import TemplateView
 url(&#39;^about/$&#39;,TemplateView.as_view(template_name=&quot;hello.html&quot;))
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;重定向并赋值&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 url(&#39;^about1/$&#39;,HomePageView.as_view())

 class HomePageView(TemplateView):
     template_name = &quot;hello.html&quot;

     #设置格外参数
     def get_context_data(self, **kwargs):
         context = super(HomePageView, self).get_context_data(**kwargs)
         context[&#39;next&#39;]=&#39;aaaaaaaaaaa&#39;
         return context
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;model&quot;&gt;显示model&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;显示model&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 url(&#39;^showpub/$&#39;,PubDetailView.as_view())

 from django.views.generic.list import ListView
 # 默认渲染 应用名/类名_list.html即books/publisher_list（小写）

 class PubDetailView(ListView):
     model=Publisher
     # model指定模型 queryset处理 因此可以在url中传任意参数供queryset处理
     queryset=Publisher.objects.filter(name=&#39;name&#39;)

     template_name = &#39;hello.html&#39;
     #模版中对应model的是object_list

     def get_context_data(self, **kwargs):
         context=super(PubDetailView,self).get_context_data(**kwargs)
         context[&#39;next&#39;]=Publisher.objects.all
         # Publisher.objects.all 后面没有括号;这表示这是一个函数的调用,并没有真正调用它(通用视图将渲染时调用它)
         return context
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;模板显示&lt;/p&gt;

    &lt;pre&gt;&lt;code&gt;
 { % for object in object_list % }
 &amp;lt; h1 &amp;gt;标题：{ { object.name } }&amp;lt; /h1 &amp;gt;
 &amp;lt; p &amp;gt;内容：{ { object.address } }&amp;lt; /p &amp;gt;
 &amp;lt; p &amp;gt;发表人: { { object.city } }&amp;lt; /p &amp;gt;
 { % endfor % }
 &lt;/code&gt;&lt;/pre&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 12 Oct 2015 05:02:18 +0800</pubDate>
        <link>/2015/10/12/Django-normal/</link>
        <guid isPermaLink="true">/2015/10/12/Django-normal/</guid>
        
        
        <category>Django</category>
        
      </item>
    
      <item>
        <title>Python Queue模块</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#section&quot; id=&quot;markdown-toc-section&quot;&gt;序&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#section-1&quot; id=&quot;markdown-toc-section-1&quot;&gt;三种队列&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-2&quot; id=&quot;markdown-toc-section-2&quot;&gt;队列存取&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-3&quot; id=&quot;markdown-toc-section-3&quot;&gt;其他方法&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#section-4&quot; id=&quot;markdown-toc-section-4&quot;&gt;　示例&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;section&quot;&gt;序&lt;/h2&gt;

&lt;p&gt;Queue类
是一个队列的同步实现,
队列长度可为无限或者有限,下面就mark一下具体的使用方法&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-1&quot;&gt;三种队列&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;queue模块有三种队列&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;python queue模块的FIFO队列先进先出。Queue.Queue(maxsize)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;LIFO类似于堆。即先进后出。Queue.LifoQueue(maxsize)&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;还有一种是优先级队列级别越低越先出来。Queue.PriorityQueue(maxsize)&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-2&quot;&gt;队列存取&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;q.put(10)：
调用队列对象的put()方法在队尾插入一个项目。put()有两个参数，第一个item为必需的，为插入项目的值；第二个block为可选参数，默认为
1。如果队列当前为满且block为1，put()方法就使调用线程暂停,直到空出一个数据单元。如果block为0，put方法将引发Full异常&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;q.get()：
调用队列对象的get()方法从队头删除并返回一个项目。可选参数为block，默认为True。如果队列为空且block为True，get()就使调用线程暂停，直至有项目可用。
如果队列为空且block为False，队列将引发Empty异常&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-3&quot;&gt;其他方法&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Queue.qsize() : 返回队列的大小&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Queue.empty() : 如果队列为空,返回True,反之False&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Queue.full() : 如果队列满了,返回True,反之False&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Queue.get_nowait() : 相当Queue.get(False)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Queue.put_nowait(item) : 相当Queue.put(item, False)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Queue.task_done() : 在完成一项工作之后,Queue.task_done() 函数向任务已经完成的队列发送一个信号Queue.join() 实际上意味着等到队列为空,再执行别的操作.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Queue.join() : 保持阻塞状态，直到处理了队列中的所有项目为止。在将一个项目添加到该队列时，未完成的任务的总数就会增加。
当使用者线程调用 task_done() 以表示检索了该项目、并完成了所有的工作时，那么未完成的任务的总数就会减少。
当未完成的任务的总数减少到零时，join() 就会结束阻塞状态。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;section-4&quot;&gt;　示例&lt;/h3&gt;

&lt;p&gt;　* 示例&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;
    def worker():
        while True:
            item = q.get()
            do_work(item)
            q.task_done()
    q = Queue()
    for i in range(num_worker_threads):
         t = Thread(target=worker)
         t.daemon = True
         t.start()
    for item in source():
        q.put(item)
    q.join()
 &lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Fri, 09 Oct 2015 04:21:12 +0800</pubDate>
        <link>/2015/10/09/Python-Queue/</link>
        <guid isPermaLink="true">/2015/10/09/Python-Queue/</guid>
        
        
        <category>Python</category>
        
      </item>
    
  </channel>
</rss>
